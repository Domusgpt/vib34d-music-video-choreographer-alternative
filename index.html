<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIB34D MASTER Music Video Choreographer</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Orbitron', monospace; background: #000; color: #0ff; overflow: hidden; }

        /* Force hide legacy UI */
        #variation-grid, .gallery-container, .trading-card-overlay, .variation-display,
        #controls-container, .tab-system, .parameter-controls { display: none !important; }

        #visualizer-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; background: #000; }
        .holographic-layers { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .holographic-layers canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }

        #controls { position: fixed; top: 20px; right: 20px; width: 420px; max-height: 90vh; background: rgba(0,0,0,0.95);
            border: 3px solid #0ff; border-radius: 15px; padding: 20px; z-index: 3000; overflow-y: auto; backdrop-filter: blur(10px); }
        #controls.mini { width: 60px; height: 60px; overflow: hidden; padding: 15px; }
        #controls.mini > *:not(.toggle-mini) { display: none; }
        .toggle-mini { position: absolute; top: 15px; right: 15px; background: rgba(0,255,255,0.2); border: 1px solid #0ff;
            color: #0ff; padding: 5px 10px; font-size: 14px; border-radius: 4px; cursor: pointer; z-index: 10; }

        h2 { text-align: center; font-size: 16px; margin-bottom: 15px; background: linear-gradient(90deg, #0ff, #f0f);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .section { margin-bottom: 15px; padding: 12px; background: rgba(0,255,255,0.05); border: 1px solid #0ff; border-radius: 8px; }
        .section h3 { font-size: 12px; color: #f0f; margin-bottom: 8px; text-transform: uppercase; }

        .param { margin-bottom: 8px; }
        .param label { display: block; font-size: 10px; color: #0ff; margin-bottom: 3px; }
        .param-val { float: right; color: #f0f; font-weight: 700; }
        input[type="range"] { width: 100%; height: 5px; background: #111; border-radius: 3px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { appearance: none; width: 14px; height: 14px;
            background: linear-gradient(135deg, #0ff, #f0f); border-radius: 50%; cursor: pointer; }

        .pills { display: flex; gap: 6px; margin-bottom: 10px; }
        .pill { flex: 1; padding: 8px; background: rgba(0,255,255,0.1); border: 2px solid #0ff; border-radius: 6px;
            text-align: center; font-size: 9px; cursor: pointer; transition: all 0.2s; }
        .pill:hover { background: rgba(0,255,255,0.2); }
        .pill.active { background: linear-gradient(135deg, #0ff, #00ff88); border-color: #00ff88; box-shadow: 0 0 15px #0ff; }

        .btn { width: 100%; padding: 10px; margin-bottom: 6px; background: linear-gradient(135deg, #0a4d68, #0ff);
            border: none; color: #000; font-family: 'Orbitron', monospace; font-weight: 700; font-size: 11px;
            border-radius: 6px; cursor: pointer; transition: all 0.2s; }
        .btn:hover:not(:disabled) { transform: scale(1.02); box-shadow: 0 0 15px #0ff; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn.ai { background: linear-gradient(135deg, #4a0a68, #f0f); }

        #timeline { position: fixed; bottom: 20px; left: 20px; right: 460px; background: rgba(0,0,0,0.95);
            border: 2px solid #f0f; border-radius: 10px; padding: 15px; z-index: 2000; }
        #timeline h3 { font-size: 12px; color: #f0f; margin-bottom: 10px; }
        .audio-btns { display: flex; gap: 8px; margin-bottom: 10px; }
        .audio-btns button { flex: 1; padding: 8px; background: linear-gradient(135deg, #4a0a68, #f0f); border: none;
            color: #000; font-family: 'Orbitron', monospace; font-weight: 700; font-size: 10px; border-radius: 5px; cursor: pointer; }
        .file-lbl { flex: 2; background: linear-gradient(135deg, #0a684a, #0f0); padding: 8px; border-radius: 5px;
            cursor: pointer; text-align: center; font-size: 10px; font-weight: 700; }
        input[type="file"] { display: none; }

        .track { position: relative; height: 60px; background: #111; border-radius: 5px; margin-bottom: 10px; overflow: hidden; }
        .playhead { position: absolute; top: 0; width: 2px; height: 100%; background: #ff0; z-index: 10; }
        .seq-block { position: absolute; height: 100%; background: linear-gradient(135deg, rgba(0,255,255,0.3), rgba(255,0,255,0.3));
            border: 2px solid #0ff; border-radius: 3px; padding: 4px; font-size: 8px; cursor: pointer; overflow: hidden; }
        .seq-block:hover { background: linear-gradient(135deg, rgba(0,255,255,0.5), rgba(255,0,255,0.5)); }

        .beat-flash { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 150px; height: 150px; border: 4px solid #0ff; border-radius: 50%; opacity: 0;
            pointer-events: none; z-index: 2500; transition: opacity 0.1s; }
        .beat-flash.hit { opacity: 0.7; animation: beatPulse 0.3s ease-out; }
        @keyframes beatPulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
            50% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.5; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }

        #ai-modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 600px; background: rgba(0,0,0,0.98); border: 3px solid #f0f; border-radius: 15px; padding: 25px; z-index: 5000; }
        #ai-modal.active { display: block; }
        #ai-modal textarea { width: 100%; height: 100px; background: #111; border: 1px solid #0ff; color: #0ff;
            padding: 10px; font-family: 'Orbitron', monospace; font-size: 12px; border-radius: 5px; margin-bottom: 10px; }
        #ai-modal input { width: 100%; background: #111; border: 1px solid #0ff; color: #0ff; padding: 8px;
            font-family: 'Orbitron', monospace; font-size: 11px; border-radius: 5px; margin-bottom: 10px; }
        .modal-btns { display: flex; gap: 10px; }

        #status { position: fixed; top: 20px; left: 20px; background: rgba(0,0,0,0.9); border: 2px solid #0ff;
            border-radius: 8px; padding: 10px 15px; font-size: 11px; z-index: 2500; max-width: 350px; }

        @media (max-width: 768px) {
            #controls { width: 95%; right: 2.5%; }
            #timeline { right: 2.5%; left: 2.5%; }
            #ai-modal { width: 90%; }
        }
    </style>
</head>
<body>
    <div id="visualizer-container">
        <div class="holographic-layers" id="vib34dLayers"></div>
        <div class="holographic-layers" id="quantumLayers" style="display: none;"></div>
        <div class="holographic-layers" id="holographicLayers" style="display: none;"></div>
    </div>

    <div class="beat-flash" id="beatFlash"></div>
    <div id="status">üéµ VIB34D MASTER Ready</div>

    <div id="controls">
        <button class="toggle-mini" onclick="window.toggleCtrl()">‚óÄ</button>
        <h2>üéõÔ∏è MASTER CONTROL</h2>

        <div class="section">
            <h3>üé® System</h3>
            <div class="pills">
                <div class="pill active" data-sys="faceted" onclick="window.switchSys('faceted')">üî∑<br>FACETED</div>
                <div class="pill" data-sys="quantum" onclick="window.switchSys('quantum')">üåå<br>QUANTUM</div>
                <div class="pill" data-sys="holographic" onclick="window.switchSys('holographic')">‚ú®<br>HOLO</div>
            </div>
        </div>

        <div class="section">
            <h3>üî∑ Geometry</h3>
            <div class="param">
                <label>Type <span class="param-val" id="v-geometry">0</span></label>
                <input type="range" id="geometry" min="0" max="7" value="0" oninput="P('geometry', this.value)">
            </div>
        </div>

        <div class="section">
            <h3>üåÄ 4D Rotation</h3>
            <div class="param">
                <label>X-W <span class="param-val" id="v-rot4dXW">0.00</span></label>
                <input type="range" id="rot4dXW" min="-6.28" max="6.28" step="0.01" value="0" oninput="P('rot4dXW', this.value)">
            </div>
            <div class="param">
                <label>Y-W <span class="param-val" id="v-rot4dYW">0.00</span></label>
                <input type="range" id="rot4dYW" min="-6.28" max="6.28" step="0.01" value="0" oninput="P('rot4dYW', this.value)">
            </div>
            <div class="param">
                <label>Z-W <span class="param-val" id="v-rot4dZW">0.00</span></label>
                <input type="range" id="rot4dZW" min="-6.28" max="6.28" step="0.01" value="0" oninput="P('rot4dZW', this.value)">
            </div>
        </div>

        <div class="section">
            <h3>üé® Visuals</h3>
            <div class="param">
                <label>Density <span class="param-val" id="v-gridDensity">15</span></label>
                <input type="range" id="gridDensity" min="5" max="100" value="15" oninput="P('gridDensity', this.value)">
            </div>
            <div class="param">
                <label>Morph <span class="param-val" id="v-morphFactor">1.0</span></label>
                <input type="range" id="morphFactor" min="0" max="2" step="0.01" value="1.0" oninput="P('morphFactor', this.value)">
            </div>
            <div class="param">
                <label>Chaos <span class="param-val" id="v-chaos">0.2</span></label>
                <input type="range" id="chaos" min="0" max="1" step="0.01" value="0.2" oninput="P('chaos', this.value)">
            </div>
            <div class="param">
                <label>Speed <span class="param-val" id="v-speed">1.0</span></label>
                <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1.0" oninput="P('speed', this.value)">
            </div>
        </div>

        <div class="section">
            <h3>üé® Color</h3>
            <div class="param">
                <label>Hue <span class="param-val" id="v-hue">200¬∞</span></label>
                <input type="range" id="hue" min="-360" max="720" value="200" oninput="P('hue', this.value)">
            </div>
            <div class="param">
                <label>Intensity <span class="param-val" id="v-intensity">0.5</span></label>
                <input type="range" id="intensity" min="0" max="2" step="0.01" value="0.5" oninput="P('intensity', this.value)">
            </div>
            <div class="param">
                <label>Saturation <span class="param-val" id="v-saturation">0.8</span></label>
                <input type="range" id="saturation" min="0" max="2" step="0.01" value="0.8" oninput="P('saturation', this.value)">
            </div>
        </div>

        <button class="btn" onclick="window.randomize()">üé≤ Randomize</button>
        <button class="btn ai" onclick="window.openAI()">ü§ñ AI Full Song Choreography</button>
        <button class="btn" id="export-btn" onclick="window.exportVid()" disabled>üé• Export Video</button>
    </div>

    <div id="timeline">
        <h3>üìΩÔ∏è TIMELINE</h3>
        <div class="audio-btns">
            <label for="audio-file" class="file-lbl">üìÅ LOAD</label>
            <input type="file" id="audio-file" accept="audio/*">
            <button id="play-btn" disabled onclick="window.play()">‚ñ∂</button>
            <button id="pause-btn" disabled onclick="window.pause()">‚è∏</button>
            <button id="stop-btn" disabled onclick="window.stop()">‚èπ</button>
            <button onclick="window.addSeq()">‚ûï</button>
        </div>
        <div class="track" id="track">
            <div class="playhead" id="playhead"></div>
        </div>
    </div>

    <div id="ai-modal">
        <h2>ü§ñ AI FULL SONG CHOREOGRAPHY</h2>
        <p style="font-size: 10px; color: #aaa; margin-bottom: 10px;">
            AI analyzes your song and creates: beat-synced color pulsing, rhythmic system switching,
            density/chaos/morph/intensity modulation, color drops on snare hits, and mid-sequence transitions.
        </p>
        <input type="text" id="api-key" placeholder="Gemini API Key (leave empty for default)">
        <textarea id="ai-prompt" placeholder="Song vibe... (e.g., 'dark techno with heavy snares' or 'dreamy trance with euphoric builds')"></textarea>
        <div class="modal-btns">
            <button class="btn ai" onclick="window.genAI()">‚ú® Generate</button>
            <button class="btn" onclick="window.closeAI()">Cancel</button>
        </div>
    </div>

    <script type="module">
        import { VIB34DIntegratedEngine } from './src/core/Engine.js';
        import { QuantumEngine } from './src/quantum/QuantumEngine.js';
        import { RealHolographicSystem } from './src/holograms/RealHolographicSystem.js';
        import { CanvasManager } from './src/core/CanvasManager.js';

        let mgr = new CanvasManager();
        let eng = null;
        let sys = 'faceted';
        let aud = new Audio();
        let ctx = new (window.AudioContext || window.webkitAudioContext)();
        let anl = ctx.createAnalyser();
        anl.fftSize = 2048;
        let dat = new Uint8Array(anl.frequencyBinCount);
        let src = null;
        let play = false;
        let par = { geometry: 0, rot4dXW: 0, rot4dYW: 0, rot4dZW: 0, gridDensity: 15, morphFactor: 1.0, chaos: 0.2, speed: 1.0, hue: 200, intensity: 0.5, saturation: 0.8 };
        let seqs = [];

        // Beat detection
        let lastBeatTime = 0;
        let beatThreshold = 0.75;
        let beatCount = 0;

        const cls = { VIB34DIntegratedEngine, QuantumEngine, RealHolographicSystem };

        (async function() {
            eng = await mgr.switchToSystem('faceted', cls);
            document.getElementById('audio-file').addEventListener('change', loadAud);
            aud.addEventListener('timeupdate', upd);
            aud.addEventListener('ended', () => window.stop());
            loop();
            stat('Ready');
        })();

        function stat(m) { document.getElementById('status').textContent = 'üéµ ' + m; }

        window.switchSys = async function(s, paramsToApply = null) {
            // Store current parameters if not provided
            const params = paramsToApply || {...par};

            console.log(`üîÑ Switching to ${s} with params:`, params);

            // Switch system
            eng = await mgr.switchToSystem(s, cls);
            sys = s;

            // Update UI
            document.querySelectorAll('.pill').forEach(p => p.classList.toggle('active', p.dataset.sys === s));

            // Wait for engine to be fully ready (CRITICAL!)
            await new Promise(resolve => setTimeout(resolve, 100));

            // Apply parameters to new engine
            Object.entries(params).forEach(([p, v]) => {
                par[p] = v;
                apply(p, v);
                // Sync UI sliders
                const slider = document.getElementById(p);
                if (slider) {
                    slider.value = v;
                    const val = p === 'hue' ? v + '¬∞' : (p === 'geometry' || p === 'gridDensity' ? parseInt(v) : parseFloat(v).toFixed(2));
                    const display = document.getElementById('v-' + p);
                    if (display) display.textContent = val;
                }
            });

            console.log(`‚úÖ ${s} ready with parameters applied`);
            stat(`Switched to ${s.toUpperCase()}`);
            return eng;
        };

        window.P = function(p, v) {
            par[p] = parseFloat(v);
            const val = p === 'hue' ? v + '¬∞' : (p === 'geometry' || p === 'gridDensity' ? parseInt(v) : parseFloat(v).toFixed(2));
            document.getElementById('v-' + p).textContent = val;
            apply(p, par[p]);
        };

        function apply(p, v) {
            if (!eng) return;
            // Clamp hue to 0-360 when applying
            if (p === 'hue') v = ((v % 360) + 360) % 360;
            if (eng.parameterManager) eng.parameterManager.setParameter(p, v);
            else if (eng.updateParameter) eng.updateParameter(p, v);
            else if (eng.updateParameters) eng.updateParameters({ [p]: v });
        }

        function applyAll() {
            Object.entries(par).forEach(([p, v]) => apply(p, v));
        }

        window.randomize = function() {
            par.geometry = Math.floor(Math.random() * 8);
            par.rot4dXW = Math.random() * 12.56 - 6.28;
            par.rot4dYW = Math.random() * 12.56 - 6.28;
            par.rot4dZW = Math.random() * 12.56 - 6.28;
            par.gridDensity = 5 + Math.random() * 95;
            par.morphFactor = Math.random() * 2;
            par.chaos = Math.random();
            par.speed = 0.1 + Math.random() * 2.9;
            par.hue = Math.random() * 360;
            par.intensity = Math.random() * 2;
            par.saturation = Math.random() * 2;
            Object.entries(par).forEach(([p, v]) => { document.getElementById(p).value = v; window.P(p, v); });
        };

        function loadAud(e) {
            const f = e.target.files[0];
            if (!f) return;
            aud.src = URL.createObjectURL(f);
            if (!src) {
                src = ctx.createMediaElementSource(aud);
                src.connect(anl);
                anl.connect(ctx.destination);
            }
            document.getElementById('play-btn').disabled = false;
            document.getElementById('pause-btn').disabled = false;
            document.getElementById('stop-btn').disabled = false;
            document.getElementById('export-btn').disabled = false;
            stat('Loaded: ' + f.name);
        }

        window.play = function() {
            if (ctx.state === 'suspended') ctx.resume();
            aud.play();
            play = true;
            stat('Playing...');
        };

        window.pause = function() { aud.pause(); play = false; stat('Paused'); };
        window.stop = function() { aud.pause(); aud.currentTime = 0; play = false; beatCount = 0; stat('Stopped'); };

        function detectBeat(bass) {
            const now = Date.now();
            if (bass > beatThreshold && now - lastBeatTime > 250) {
                lastBeatTime = now;
                beatCount++;

                // Visual beat flash
                const flash = document.getElementById('beatFlash');
                flash.classList.remove('hit');
                setTimeout(() => flash.classList.add('hit'), 10);

                return true;
            }
            return false;
        }

        let sequenceSwitching = false;

        async function loop() {
            if (play) {
                anl.getByteFrequencyData(dat);
                const b = avg(0, 100) / 255;
                const m = avg(100, 400) / 255;
                const h = avg(400, 1024) / 255;
                const e = (b + m + h) / 3;

                const t = aud.currentTime;
                const beat = detectBeat(b);

                // Algorithmic patterns
                const pulse = Math.sin(t * 2) * 0.5 + 0.5;
                const breathe = Math.sin(t * 0.5) * 0.5 + 0.5;

                // Apply reactivity
                apply('gridDensity', par.gridDensity + b * 60 + pulse * 25);
                apply('morphFactor', par.morphFactor + m * 0.9 + breathe * 0.5);
                apply('chaos', par.chaos + h * 0.7 + pulse * 0.4);
                apply('speed', par.speed + e * 1.4);
                apply('intensity', par.intensity + e * 0.8 + (beat ? 0.5 : 0));
                apply('saturation', par.saturation + b * 0.5 + (beat ? 0.3 : 0));

                // 4D rotation dynamics
                apply('rot4dXW', Math.sin(t * 0.3 + b * Math.PI * 2) * 3.14);
                apply('rot4dYW', Math.cos(t * 0.5 + m * Math.PI * 2) * 3.14);
                apply('rot4dZW', Math.sin(t * 0.7 + h * Math.PI * 2) * 3.14);

                // Check sequence
                const ac = seqs.find(s => t >= s.time && t < s.time + s.dur);
                if (ac) {
                    // Mid-sequence system switching
                    if (ac.sysSwitch) {
                        const switches = ac.sysSwitch;
                        for (let sw of switches) {
                            if (t >= ac.time + sw.at && t < ac.time + sw.at + 0.5) {
                                if (sys !== sw.to && !sequenceSwitching) {
                                    sequenceSwitching = true;
                                    await window.switchSys(sw.to, ac.par);
                                    sequenceSwitching = false;
                                }
                            }
                        }
                    }

                    // Main sequence system switching with parameters
                    if (ac.sys && ac.sys !== sys && !ac.sysSwitch && !sequenceSwitching) {
                        sequenceSwitching = true;
                        await window.switchSys(ac.sys, ac.par);
                        sequenceSwitching = false;
                    } else if (ac.par) {
                        // Apply parameters if no system switch needed
                        Object.entries(ac.par).forEach(([p, v]) => apply(p, v));
                    }

                    // INTRICATE BEAT-SYNCED PATTERNS

                    // densityPulse - cycling density values on every beat
                    if (ac.densityPulse && beat) {
                        const densities = ac.densityPulse;
                        const idx = beatCount % densities.length;
                        apply('gridDensity', densities[idx]);
                    }

                    // colorPulse - cycling hue values on every beat
                    if (ac.colorPulse && beat) {
                        const colors = ac.colorPulse;
                        const idx = beatCount % colors.length;
                        apply('hue', colors[idx]);
                    }

                    // saturationSnap - rhythmic saturation patterns
                    if (ac.saturationSnap && beat) {
                        const saturations = ac.saturationSnap;
                        const idx = beatCount % saturations.length;
                        apply('saturation', saturations[idx]);
                    }

                    // geometryMeasures - change geometry on measure boundaries (every 4 beats)
                    if (ac.geometryMeasures && beat && beatCount % 4 === 0) {
                        const geometries = ac.geometryMeasures;
                        const measureIdx = Math.floor(beatCount / 4) % geometries.length;
                        apply('geometry', geometries[measureIdx]);
                    }

                    // Color drop on snare (legacy support)
                    if (ac.colorDrop && beat && beatCount % ac.colorDrop === 0) {
                        apply('saturation', 0);
                        setTimeout(() => apply('saturation', par.saturation), 100);
                    }

                    // Parameter modulation - ADD to base values on every beat
                    if (ac.densityMod && beat) apply('gridDensity', par.gridDensity + ac.densityMod);
                    if (ac.chaosMod && beat) apply('chaos', Math.min(1, par.chaos + ac.chaosMod));
                    if (ac.morphMod && beat) apply('morphFactor', Math.min(2, par.morphFactor + ac.morphMod));
                    if (ac.intensityMod && beat) apply('intensity', Math.min(2, par.intensity + ac.intensityMod));

                    // Patterns
                    if (ac.pattern) applyPat(ac.pattern, t - ac.time, ac.dur);
                }
            }
            requestAnimationFrame(loop);
        }

        function applyPat(pat, t, dur) {
            const prog = t / dur;
            if (pat === 'density_pulse') apply('gridDensity', par.gridDensity + Math.sin(prog * Math.PI * 4) * 40);
            else if (pat === 'rotation_spin') {
                apply('rot4dXW', prog * Math.PI * 4);
                apply('rot4dYW', prog * Math.PI * 3);
                apply('rot4dZW', prog * Math.PI * 5);
            } else if (pat === 'color_shift') apply('hue', (par.hue + prog * 180) % 360);
            else if (pat === 'chaos_build') apply('chaos', Math.min(1, par.chaos + prog * 0.8));
            else if (pat === 'morph_wave') apply('morphFactor', par.morphFactor + Math.sin(prog * Math.PI * 2) * 0.9);
        }

        function avg(s, e) {
            let sum = 0;
            for (let i = s; i < e; i++) sum += dat[i];
            return sum / (e - s);
        }

        function upd() {
            if (!aud.duration) return;
            document.getElementById('playhead').style.left = (aud.currentTime / aud.duration * 100) + '%';
        }

        function rend() {
            const tr = document.getElementById('track');
            const ph = document.getElementById('playhead');
            tr.innerHTML = '';
            tr.appendChild(ph);
            seqs.forEach(s => {
                const b = document.createElement('div');
                b.className = 'seq-block';
                b.style.left = (s.time / aud.duration * 100) + '%';
                b.style.width = (s.dur / aud.duration * 100) + '%';
                b.innerHTML = `${s.sys ? s.sys.toUpperCase() : 'SEQ'}<br>${s.time.toFixed(1)}s`;
                b.onclick = async () => {
                    aud.currentTime = s.time;
                    beatCount = 0;
                    // Switch system with sequence parameters
                    if (s.sys && s.sys !== sys) {
                        await window.switchSys(s.sys, s.par);
                    } else if (s.par) {
                        // Apply parameters without switching
                        Object.entries(s.par).forEach(([p, v]) => {
                            par[p] = v;
                            const slider = document.getElementById(p);
                            if (slider) slider.value = v;
                            window.P(p, v);
                        });
                    }
                };
                tr.appendChild(b);
            });
        }

        window.toggleCtrl = function() {
            document.getElementById('controls').classList.toggle('mini');
            document.querySelector('.toggle-mini').textContent = document.getElementById('controls').classList.contains('mini') ? '‚ñ∂' : '‚óÄ';
        };

        window.addSeq = function() {
            const t = aud.currentTime || 0;
            const seq = {
                name: `Manual ${seqs.length + 1}`,
                time: t,
                dur: 10,
                sys: sys,
                par: {...par},
                // Add intricate beat-synced patterns
                densityPulse: [par.gridDensity - 10, par.gridDensity, par.gridDensity + 10, par.gridDensity],
                colorPulse: [par.hue, (par.hue + 60) % 360, (par.hue + 120) % 360, (par.hue + 60) % 360],
                densityMod: 25,
                chaosMod: 0.15,
                morphMod: 0.25,
                intensityMod: 0.35
            };
            seqs.push(seq);
            seqs.sort((a, b) => a.time - b.time);
            rend();
            stat(`Added intricate sequence at ${t.toFixed(1)}s with beat patterns`);
        };

        window.openAI = function() { document.getElementById('ai-modal').classList.add('active'); };
        window.closeAI = function() { document.getElementById('ai-modal').classList.remove('active'); };

        window.genAI = async function() {
            const prompt = document.getElementById('ai-prompt').value;
            if (!prompt) return alert('Enter description');

            const key = document.getElementById('api-key').value || 'YOUR_GEMINI_API_KEY_HERE';
            const dur = aud.duration || 180;
            stat('AI generating with beat sync...');

            try {
                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${key}`;
                const resp = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: `You are a MASTER music visualization choreographer creating SURGICAL PRECISION choreography for: "${prompt}"

Duration: ${dur.toFixed(0)}s

üéØ CRITICAL RULES FOR INTRICATE CHOREOGRAPHY:

## BEAT-LEVEL PRECISION:

**DENSITY PATTERNS - Rhythmic Back-and-Forth:**
- densityPulse: [30, 60, 90, 60] = cycles EVERY BEAT (4-beat pattern)
- densitySnap: [20, 80, 20, 80] = hard snap on/off (snare pattern)
- densityBuild: [10, 20, 30, 40, 50, 60, 70, 80] = 8-beat build
- Use densityMod for EVERY beat hit (not just some beats!)

**COLOR PATTERNS - Beat-Synced Cycles:**
- colorPulse: [0, 120, 240, 60, 180, 300] = 6-beat rainbow cycle
- colorBeat: [30, 30, 210, 210] = 2-beat color holds
- colorWave: [0, 45, 90, 135, 180, 225, 270, 315] = smooth 8-beat spectrum sweep
- ALWAYS use colorPulse for rhythmic color changes!

**CHAOS/MORPH CALIBRATION:**
- chaos: 0-0.3 = controlled (verses/intros)
- chaos: 0.4-0.6 = moderate (builds)
- chaos: 0.7-0.9 = intense (pre-drops)
- chaos: 0.95-1.0 = MAXIMUM (drops only!)
- morphFactor: 0.5-1.0 = subtle (most of the time)
- morphFactor: 1.2-1.8 = dramatic (highlights)

**GEOMETRY CHANGES - Measure-Based:**
- geometryMeasures: [0, 1, 5, 2, 3, 5, 7, 1] = change geometry every 4 measures
- Use geometry changes at MUSICAL PHRASES (8, 16, 32 beat intervals)
- NOT on every beat - only on STRUCTURAL changes

## BEAT MODS - MUST USE ALL:

```json
{
  "densityPulse": [20, 40, 60, 80, 60, 40],  // 6-beat cycle
  "colorPulse": [0, 60, 120, 180, 240, 300],  // Rainbow every 6 beats
  "densityMod": 40,        // +40 density on EVERY beat
  "chaosMod": 0.15,        // +0.15 chaos on EVERY beat (subtle)
  "morphMod": 0.3,         // +0.3 morph on EVERY beat
  "intensityMod": 0.4,     // +0.4 intensity on EVERY beat (strobe)
  "saturationSnap": [1.5, 0.2, 1.5, 0.2],  // Saturation snap on/off every 2 beats
  "geometryMeasures": [1, 5, 2, 7, 3, 6, 4, 0]  // Geometry rotation every 4 measures
}
```

## PARAMETERS - PROPER USAGE:

**gridDensity:**
- 5-15: Minimal, spacious (intros/outros)
- 20-40: Medium detail (verses)
- 45-70: High detail (builds)
- 75-95: Extreme detail (drops)
- NEVER stay at one value - use densityPulse!

**hue:**
- Single value: 0-360 (pick one base color per sequence)
- THEN use colorPulse for beat-synced variations around that base
- Example: hue:180 (cyan base), colorPulse:[160,180,200,220] (cyan variations)

**intensity:**
- 0.2-0.4: Dark (breakdowns)
- 0.5-0.8: Normal (verses)
- 0.9-1.5: Bright (builds/drops)
- Use intensityMod for beat strobes!

**saturation:**
- 0.1-0.3: Washed out (ethereal)
- 0.5-0.9: Normal (most content)
- 1.0-1.8: Hyper-saturated (drops)
- Use saturationSnap for rhythmic desaturation!

**chaos/morph:**
- CALIBRATE these carefully!
- chaos > 0.8 = visual chaos (use sparingly!)
- morphFactor > 1.5 = extreme warping (drops only!)

**4D rotations:**
- Use rot4dXW/YW/ZW for BASE rotation
- Then let audio reactivity ADD to it (already happens in code)
- Slow rotations (0.1-0.5) for clarity
- Fast rotations (1.0-2.0) for intensity

## SYSTEM SWITCHING:

**faceted:** Clean, geometric, BEST for intricate beat patterns
**quantum:** Complex lattice, BEST for layered chaos
**holographic:** Audio-reactive, BEST for organic flow

Use sysSwitch for RHYTHMIC system changes:
```json
"sysSwitch": [
  {"at": 4, "to": "quantum"},   // Switch at 4s into sequence
  {"at": 8, "to": "faceted"},   // Switch back at 8s
  {"at": 12, "to": "quantum"}   // Final switch at 12s
]
```

## PATTERNS - USE THESE:

**density_pulse:** Sine wave density breathing
**rotation_spin:** Accelerating 4D spins
**color_shift:** Spectrum sweep
**chaos_build:** Progressive entropy increase
**morph_wave:** Oscillating shape morphing

COMBINE patterns with beat mods for layered complexity!

## üéµ SEQUENCE STRUCTURE (20-30 sequences):

**INTRO (0-16s):**
- geometry: 0, density: 10, chaos: 0.1, morph: 0.8
- densityPulse: [8, 12, 16, 12], colorPulse: [180, 200, 220, 200]
- pattern: "density_pulse"

**VERSE 1 (16-48s):**
- geometry: 1, density: 25, chaos: 0.2, morph: 1.0
- densityPulse: [20, 30, 40, 30], colorPulse: [0, 30, 60, 30]
- densityMod: 20, chaosMod: 0.1, morphMod: 0.2
- geometryMeasures: [1, 2, 1, 5]

**BUILD 1 (48-64s):**
- geometry: 5, density: 40‚Üí70 (sweep!)
- densityPulse: [40, 50, 60, 70, 80], colorPulse: [0, 60, 120, 180, 240]
- densityMod: 35, chaosMod: 0.3, intensityMod: 0.5
- pattern: "chaos_build"

**DROP 1 (64-96s):**
- geometry: 5, density: 90, chaos: 0.95, morph: 1.8, sys: "quantum"
- densityPulse: [85, 95, 100, 95, 90, 95], colorPulse: [0, 180, 0, 180]
- densityMod: 45, chaosMod: 0.5, morphMod: 0.8, intensityMod: 0.8
- saturationSnap: [1.8, 0.1, 1.8, 0.1] (snare drops!)
- sysSwitch: [{"at": 8, "to": "holographic"}, {"at": 16, "to": "quantum"}]
- geometryMeasures: [5, 7, 5, 3, 5, 7]

**BREAKDOWN (96-112s):**
- geometry: 2, density: 8, chaos: 0.1, morph: 0.5, sys: "holographic"
- densityPulse: [6, 8, 10, 8], colorPulse: [200, 220, 240, 220]
- pattern: "density_pulse"

**BUILD 2 (112-128s):**
- Repeat build structure with different colors/geometries

**FINAL DROP (128-end):**
- EVERYTHING MAXED with ALL beat mods active
- geometryMeasures changes every 2 measures
- Rapid sysSwitch between all 3 systems

## CRITICAL REQUIREMENTS:

1. **EVERY sequence MUST have densityPulse** (beat-synced density)
2. **EVERY sequence MUST have colorPulse** (beat-synced colors)
3. **Drops MUST have densityMod + chaosMod + morphMod + intensityMod** (all 4!)
4. **geometryMeasures for phrase-level changes** (not beat-level!)
5. **Calibrate chaos/morph properly** (don't max everything!)
6. **Use saturationSnap for rhythmic color drops**
7. **Combine patterns with beat mods** for layered complexity
8. **Use ALL 3 systems** throughout the song

Return ONLY the JSON array with 20-30 sequences. EVERY sequence MUST have intricate beat-synced patterns!`
                            }]
                        }]
                    })
                });

                const data = await resp.json();
                const txt = data.candidates[0].content.parts[0].text;
                const json = txt.match(/\[[\s\S]*\]/)[0];
                seqs = JSON.parse(json);
                rend();
                beatCount = 0;
                stat(`AI: ${seqs.length} seqs with beat sync!`);
                window.closeAI();
            } catch (err) {
                stat('AI failed: ' + err.message);
                console.error(err);
            }
        };

        window.exportVid = async function() {
            if (!aud.src) {
                alert('‚ö†Ô∏è Load an audio file first!');
                return;
            }

            // Check MediaRecorder support
            if (!window.MediaRecorder) {
                alert('‚ùå Video recording not supported in this browser. Try Chrome or Edge.');
                return;
            }

            stat('Preparing export...');

            // Get the currently VISIBLE canvas
            const allCanvases = Array.from(document.querySelectorAll('canvas'));
            console.log('üé• Found canvases:', allCanvases.map(c => ({
                id: c.id,
                visible: c.offsetParent !== null,
                width: c.offsetWidth,
                height: c.offsetHeight
            })));

            const visibleCanvas = allCanvases.find(c => c.offsetParent !== null && c.offsetWidth > 0);

            if (!visibleCanvas) {
                alert('‚ùå No visible canvas found! Switch to a system first (Faceted/Quantum/Holographic).');
                return;
            }

            console.log('üé• Recording canvas:', visibleCanvas.id, visibleCanvas.width, 'x', visibleCanvas.height);

            // Check canvas has content
            if (visibleCanvas.width === 0 || visibleCanvas.height === 0) {
                alert('‚ùå Canvas has no content. Make sure visualization is running.');
                return;
            }

            // Try different MediaRecorder mimeTypes for compatibility
            let mimeType = 'video/webm;codecs=vp9';
            if (!MediaRecorder.isTypeSupported(mimeType)) {
                console.warn('vp9 not supported, trying vp8...');
                mimeType = 'video/webm;codecs=vp8';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    console.warn('vp8 not supported, using default...');
                    mimeType = 'video/webm';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        alert('‚ùå WebM recording not supported in this browser. Try Chrome or Edge.');
                        return;
                    }
                }
            }

            console.log('üé• Using mimeType:', mimeType);

            try {
                // Capture canvas stream at 60fps
                const videoStream = visibleCanvas.captureStream(60);

                // Create destination to tap audio from EXISTING audio context
                const exportDest = ctx.createMediaStreamDestination();

                // Connect analyser to export destination (tap the audio)
                anl.connect(exportDest);

                // Combine video + audio streams
                const combinedStream = new MediaStream([
                    ...videoStream.getVideoTracks(),
                    ...exportDest.stream.getAudioTracks()
                ]);

                // Create MediaRecorder
                const recorder = new MediaRecorder(combinedStream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: 8000000
                });

                const chunks = [];

                recorder.ondataavailable = e => {
                    if (e.data && e.data.size > 0) {
                        chunks.push(e.data);
                        stat(`Recording... ${(chunks.length * 0.1).toFixed(1)}s`);
                    }
                };

                recorder.onstop = () => {
                    console.log('üé• Recorder stopped, chunks:', chunks.length);

                    // Clean up audio tap
                    anl.disconnect(exportDest);

                    if (chunks.length === 0) {
                        stat('Export failed: No data recorded');
                        return;
                    }

                    const blob = new Blob(chunks, { type: 'video/webm' });
                    console.log('üé• Blob size:', (blob.size / 1024 / 1024).toFixed(2), 'MB');

                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `vib34d-choreography-${Date.now()}.webm`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);

                    setTimeout(() => URL.revokeObjectURL(url), 1000);
                    stat('‚úÖ Export complete! Video downloaded');
                };

                recorder.onerror = e => {
                    console.error('üé• Recorder error:', e);
                    stat('Export failed: ' + (e.error || 'Unknown error'));
                    anl.disconnect(exportDest);
                };

                // Start recording
                console.log('üé• Starting recorder...');
                recorder.start(100); // Collect data every 100ms

                // Restart audio from beginning
                aud.currentTime = 0;
                beatCount = 0;

                await aud.play();
                stat('üî¥ Recording...');

                // Stop recording when audio ends
                aud.onended = () => {
                    console.log('üé• Audio ended, stopping recorder');
                    if (recorder.state === 'recording') {
                        recorder.stop();
                    }
                };

            } catch (err) {
                console.error('üé• Export setup error:', err);
                stat('Export failed: ' + err.message);
            }
        };
    </script>
</body>
</html>
