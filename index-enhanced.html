<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIB34D Ultimate Music Video Choreographer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0ff;
            overflow: hidden;
        }

        /* CRITICAL: Only one system canvas visible at a time for mobile performance */
        #stage-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .system-canvases {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none; /* Hidden by default - only active system shown */
        }

        .system-canvases.active {
            display: block;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Choreographer UI */
        #choreographer-ui {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 280px;
            background: rgba(0, 0, 0, 0.92);
            border-top: 2px solid #0ff;
            z-index: 100;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
        }

        #choreographer-ui.collapsed {
            transform: translateY(240px);
        }

        #ui-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: rgba(0, 255, 255, 0.1);
            border-bottom: 1px solid #0ff;
        }

        #ui-header h2 {
            font-size: 14px;
            letter-spacing: 2px;
        }

        #ui-controls {
            display: flex;
            gap: 10px;
        }

        .ui-btn {
            background: transparent;
            border: 1px solid #0ff;
            color: #0ff;
            padding: 5px 12px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        .ui-btn:hover {
            background: #0ff;
            color: #000;
        }

        .ui-btn.active {
            background: #0ff;
            color: #000;
        }

        /* Timeline */
        #timeline-container {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
        }

        #timeline {
            position: relative;
            height: 100%;
            background: linear-gradient(90deg, rgba(0,255,255,0.05) 0%, transparent 100%);
            border: 1px solid rgba(0,255,255,0.3);
            border-radius: 4px;
        }

        .timeline-track {
            height: 40px;
            border-bottom: 1px solid rgba(0,255,255,0.2);
            position: relative;
        }

        .timeline-track:last-child {
            border-bottom: none;
        }

        .track-label {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            letter-spacing: 1px;
            pointer-events: none;
        }

        .sequence-block {
            position: absolute;
            height: 32px;
            top: 4px;
            background: rgba(0, 255, 255, 0.3);
            border: 1px solid #0ff;
            border-radius: 3px;
            cursor: move;
            padding: 5px;
            font-size: 9px;
            overflow: hidden;
            white-space: nowrap;
            user-select: none;
            transition: background 0.2s;
        }

        .sequence-block:hover {
            background: rgba(0, 255, 255, 0.5);
        }

        .sequence-block.active {
            background: rgba(255, 0, 255, 0.5);
            border-color: #f0f;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
        }

        /* Control Panel */
        #control-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 320px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #0ff;
            padding: 15px;
            z-index: 101;
            max-height: calc(100vh - 320px);
            overflow-y: auto;
        }

        #control-panel h3 {
            font-size: 12px;
            letter-spacing: 2px;
            margin-bottom: 15px;
            color: #0ff;
            border-bottom: 1px solid #0ff;
            padding-bottom: 5px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 10px;
            letter-spacing: 1px;
            margin-bottom: 5px;
            color: #0ff;
        }

        .control-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input[type="range"] {
            flex: 1;
            height: 20px;
            -webkit-appearance: none;
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #0ff;
            border-radius: 3px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: #0ff;
            cursor: pointer;
            border-radius: 2px;
        }

        .value-display {
            font-size: 10px;
            color: #0ff;
            min-width: 40px;
            text-align: right;
        }

        select {
            width: 100%;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
            color: #0ff;
            padding: 8px;
            font-family: inherit;
            font-size: 11px;
        }

        /* System indicators */
        .system-pills {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .system-pill {
            flex: 1;
            padding: 8px;
            text-align: center;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
            font-size: 9px;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .system-pill:hover {
            background: rgba(0, 255, 255, 0.2);
        }

        .system-pill.active {
            background: #0ff;
            color: #000;
            font-weight: bold;
        }

        /* Color coordination */
        .color-preset-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            margin-bottom: 10px;
        }

        .color-preset {
            height: 30px;
            border: 1px solid #0ff;
            cursor: pointer;
            border-radius: 3px;
            transition: transform 0.2s;
        }

        .color-preset:hover {
            transform: scale(1.1);
            border-width: 2px;
        }

        /* Playback controls */
        #playback-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        #playback-controls button {
            flex: 1;
        }

        /* Audio file upload */
        #audio-upload-section {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 255, 255, 0.05);
            border: 1px dashed #0ff;
            border-radius: 4px;
        }

        #audio-file-input {
            width: 100%;
            color: #0ff;
            font-size: 10px;
            padding: 5px;
        }

        /* Pattern library */
        .pattern-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid rgba(0, 255, 255, 0.3);
            padding: 5px;
        }

        .pattern-item {
            padding: 5px;
            margin-bottom: 3px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid transparent;
            cursor: pointer;
            font-size: 9px;
            border-radius: 2px;
        }

        .pattern-item:hover {
            border-color: #0ff;
            background: rgba(0, 255, 255, 0.2);
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            #control-panel {
                width: calc(100% - 40px);
                right: 20px;
                max-height: 40vh;
            }

            #choreographer-ui {
                height: 200px;
            }

            #choreographer-ui.collapsed {
                transform: translateY(160px);
            }
        }

        /* Loading indicator */
        #loading-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #0ff;
            padding: 30px;
            z-index: 1000;
            text-align: center;
        }

        #loading-indicator.hidden {
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(0, 255, 255, 0.3);
            border-top-color: #0ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loading-indicator">
        <div class="spinner"></div>
        <div>INITIALIZING VIB34D CHOREOGRAPHER...</div>
    </div>

    <div id="stage-container">
        <!-- Canvas container - canvases dynamically created per system -->
    </div>

    <!-- AI Section Display -->
    <div id="ai-section-display" style="position: fixed; top: 20px; left: 20px; background: rgba(0,0,0,0.9); border: 2px solid #0ff; padding: 15px; z-index: 102; min-width: 300px; display: none;">
        <h3 style="margin: 0 0 10px 0; font-size: 14px; color: #0ff;">üé≠ AI CHOREOGRAPHY</h3>
        <div id="current-section" style="font-size: 18px; color: #fff; margin-bottom: 10px;">No section active</div>
        <div id="section-details" style="font-size: 11px; color: #aaa; line-height: 1.6;">
            <div>System: <span id="section-system">-</span></div>
            <div>Mode: <span id="section-mode">-</span></div>
            <div>Geometry: <span id="section-geometry">-</span></div>
            <div>Time: <span id="section-time">0:00</span> / <span id="section-duration">0:00</span></div>
        </div>
        <div id="section-progress-bar" style="margin-top: 10px; height: 4px; background: rgba(0,255,255,0.2); border-radius: 2px; overflow: hidden;">
            <div id="section-progress-fill" style="height: 100%; background: #0ff; width: 0%; transition: width 0.1s linear;"></div>
        </div>
        <div id="next-section" style="margin-top: 10px; font-size: 10px; color: #f0f;">
            Next: <span id="next-section-name">-</span> in <span id="next-section-time">0s</span>
        </div>
    </div>

    <!-- LLM Parameter Control Panel -->
    <div id="llm-panel" style="position: fixed; top: 20px; left: 20px; background: rgba(0, 0, 0, 0.95); border: 2px solid #f0f; border-radius: 15px; padding: 20px; z-index: 1500; display: none; flex-direction: column; gap: 15px; min-width: 350px; max-width: 400px;">
        <h3 style="color: #f0f; margin-bottom: 10px; font-size: 16px;">ü§ñ AI PARAMETER CONTROL</h3>
        <textarea id="llm-input" placeholder="Describe the visual vibe you want...

Examples:
- 'cosmic loneliness with vast empty spaces'
- 'aggressive metallic chaos with red hues'
- 'peaceful flowing water meditation'
- 'psychedelic rainbow explosions'" style="width: 100%; background: #111; border: 1px solid #f0f; color: #0ff; padding: 12px; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 12px; min-height: 100px; resize: vertical;"></textarea>
        <button id="llm-generate" onclick="generateFromAI()" style="background: linear-gradient(135deg, #4a0a68, #f0f); border: none; color: #fff; padding: 12px 24px; font-family: 'Courier New', monospace; font-weight: 700; font-size: 12px; border-radius: 8px; cursor: pointer; text-transform: uppercase;">‚ú® GENERATE PARAMETERS</button>
        <div style="font-size: 10px; color: #666;">
            <label>API Key (stored locally):</label>
            <input type="password" id="llm-api-key-input" placeholder="AIza..." value="AIzaSyD1dHwFcwVxg6r-Lt8I7U6CgznDfwn4GeI" style="width: 100%; background: #111; border: 1px solid #f0f; color: #0ff; padding: 8px; border-radius: 5px; font-family: 'Courier New', monospace; font-size: 10px;">
        </div>
        <div id="llm-status" style="font-size: 11px; color: #aaa; text-align: center;">Enter description and click Generate</div>
    </div>

    <div id="control-panel">
        <h3>üé¨ CHOREOGRAPHY CONTROL</h3>

        <div id="audio-upload-section">
            <label style="font-size: 10px; margin-bottom: 5px; display: block;">üìÅ LOAD AUDIO FILE</label>
            <input type="file" id="audio-file-input" accept="audio/*">
        </div>

        <div class="control-group" style="margin-top: 10px;">
            <button class="ui-btn" id="toggle-llm-btn" style="width: 100%; font-size: 10px; background: linear-gradient(135deg, #4a0a68, #f0f); color: #fff; border: 1px solid #f0f;">ü§ñ AI PARAMETER CONTROL</button>
        </div>

        <div class="control-group" style="margin-top: 10px;">
            <label style="font-size: 10px; margin-bottom: 5px; display: block;">ü§ñ GEMINI API KEY (for AI choreography)</label>
            <input type="password" id="gemini-api-key" placeholder="Enter Gemini API key..." value="AIzaSyD1dHwFcwVxg6r-Lt8I7U6CgznDfwn4GeI" style="width: 100%; padding: 5px; font-size: 9px; background: rgba(0,255,255,0.1); border: 1px solid #0ff; color: #0ff;">
            <button class="ui-btn" id="analyze-song-btn" style="width: 100%; margin-top: 5px; font-size: 9px;">üéµ ANALYZE SONG WITH AI</button>
            <div id="ai-analysis-status" style="font-size: 8px; margin-top: 5px; color: #0ff;"></div>
        </div>

        <div class="control-group" style="margin-top: 10px; border-top: 1px solid rgba(0,255,255,0.3); padding-top: 10px;">
            <label style="font-size: 10px; margin-bottom: 5px; display: block;">üé• VIDEO EXPORT</label>
            <button class="ui-btn" id="export-video-btn" style="width: 100%; font-size: 9px; background: #0f0;">üíæ EXPORT VIDEO (1-CLICK AUTO)</button>
            <button class="ui-btn" id="start-recording-btn" style="width: 100%; margin-top: 5px; font-size: 9px; background: #f80;">‚è∫ MANUAL RECORD</button>
            <button class="ui-btn" id="stop-recording-btn" style="width: 100%; margin-top: 5px; font-size: 9px; background: #555; display: none;">‚èπ STOP RECORDING</button>
            <div id="export-status" style="font-size: 8px; margin-top: 5px; color: #0f0;"></div>
            <div id="export-progress" style="margin-top: 5px; height: 4px; background: rgba(0,255,0,0.2); border-radius: 2px; overflow: hidden; display: none;">
                <div id="export-progress-fill" style="height: 100%; background: #0f0; width: 0%; transition: width 0.3s;"></div>
            </div>
        </div>

        <div class="system-pills">
            <div class="system-pill active" data-system="faceted">FACETED</div>
            <div class="system-pill" data-system="quantum">QUANTUM</div>
            <div class="system-pill" data-system="holographic">HOLO</div>
        </div>

        <div class="control-group">
            <label>GEOMETRY</label>
            <select id="geometry-select">
                <option value="0">Tetrahedron</option>
                <option value="1" selected>Hypercube</option>
                <option value="2">Sphere</option>
                <option value="3">Torus</option>
                <option value="4">Klein Bottle</option>
                <option value="5">Fractal</option>
                <option value="6">Wave</option>
                <option value="7">Crystal</option>
            </select>
        </div>

        <div class="control-group">
            <label>COLOR PRESETS</label>
            <div class="color-preset-grid">
                <div class="color-preset" style="background: linear-gradient(135deg, #ff0080, #7928ca)" data-hue="320"></div>
                <div class="color-preset" style="background: linear-gradient(135deg, #00f5ff, #0080ff)" data-hue="190"></div>
                <div class="color-preset" style="background: linear-gradient(135deg, #ff0000, #ff6600)" data-hue="15"></div>
                <div class="color-preset" style="background: linear-gradient(135deg, #00ff00, #00ffaa)" data-hue="150"></div>
                <div class="color-preset" style="background: linear-gradient(135deg, #ffff00, #ff9900)" data-hue="45"></div>
                <div class="color-preset" style="background: linear-gradient(135deg, #ff00ff, #8800ff)" data-hue="280"></div>
                <div class="color-preset" style="background: linear-gradient(135deg, #ffffff, #aaaaaa)" data-hue="0"></div>
                <div class="color-preset" style="background: linear-gradient(135deg, #00ffff, #00ff80)" data-hue="170"></div>
            </div>
        </div>

        <div class="control-group">
            <label>GRID DENSITY: <span id="density-val" class="value-display">15</span></label>
            <input type="range" id="density-slider" min="5" max="100" value="15">
        </div>

        <div class="control-group">
            <label>MORPH FACTOR: <span id="morph-val" class="value-display">1.0</span></label>
            <input type="range" id="morph-slider" min="0" max="2" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label>CHAOS: <span id="chaos-val" class="value-display">0.2</span></label>
            <input type="range" id="chaos-slider" min="0" max="1" step="0.05" value="0.2">
        </div>

        <div class="control-group">
            <label>SPEED: <span id="speed-val" class="value-display">1.0</span></label>
            <input type="range" id="speed-slider" min="0.1" max="3" step="0.1" value="1.0">
        </div>

        <h3 style="margin-top: 20px;">üåÄ 4D ROTATIONS</h3>

        <div class="control-group">
            <label>ROT XW: <span id="rot4d-xw-val" class="value-display">0.0</span></label>
            <input type="range" id="rot4d-xw-slider" min="-6.28" max="6.28" step="0.1" value="0.0">
        </div>

        <div class="control-group">
            <label>ROT YW: <span id="rot4d-yw-val" class="value-display">0.0</span></label>
            <input type="range" id="rot4d-yw-slider" min="-6.28" max="6.28" step="0.1" value="0.0">
        </div>

        <div class="control-group">
            <label>ROT ZW: <span id="rot4d-zw-val" class="value-display">0.0</span></label>
            <input type="range" id="rot4d-zw-slider" min="-6.28" max="6.28" step="0.1" value="0.0">
        </div>

        <div class="control-group">
            <label>
                <input type="checkbox" id="audio-reactive-toggle" checked>
                AUDIO REACTIVITY
            </label>
            <label>STRENGTH: <span id="reactivity-strength-val" class="value-display">0.5</span></label>
            <input type="range" id="reactivity-strength-slider" min="0" max="1" step="0.1" value="0.5">
        </div>

        <h3 style="margin-top: 20px;">üéµ PATTERN LIBRARY</h3>
        <div class="pattern-list">
            <div class="pattern-item" data-pattern="pulse-grow">Density Pulse +3-2 Growing</div>
            <div class="pattern-item" data-pattern="geometry-switch">Geometry on Snare Hits</div>
            <div class="pattern-item" data-pattern="color-sweep">Color Sweep Sequence</div>
            <div class="pattern-item" data-pattern="chaos-burst">Chaos Burst on Drops</div>
            <div class="pattern-item" data-pattern="rotation-spin">4D Rotation Spin</div>
            <div class="pattern-item" data-pattern="system-cycle">System Cycle (All 3)</div>
        </div>

        <div id="playback-controls">
            <button class="ui-btn" id="play-btn">‚ñ∂ PLAY</button>
            <button class="ui-btn" id="pause-btn">‚è∏ PAUSE</button>
            <button class="ui-btn" id="stop-btn">‚èπ STOP</button>
        </div>
    </div>

    <div id="choreographer-ui">
        <div id="ui-header">
            <h2>üé¨ VISUAL TIMELINE CHOREOGRAPHER</h2>
            <div id="ui-controls">
                <button class="ui-btn" id="add-sequence-btn">+ ADD SEQUENCE</button>
                <button class="ui-btn" id="export-btn">üíæ EXPORT</button>
                <button class="ui-btn" id="import-btn">üìÇ IMPORT</button>
                <button class="ui-btn" id="collapse-btn">‚ñº</button>
            </div>
        </div>
        <div id="timeline-container">
            <div id="timeline">
                <div class="timeline-track">
                    <div class="track-label">FACETED</div>
                </div>
                <div class="timeline-track">
                    <div class="track-label">QUANTUM</div>
                </div>
                <div class="timeline-track">
                    <div class="track-label">HOLOGRAPHIC</div>
                </div>
                <div class="timeline-track">
                    <div class="track-label">COLOR</div>
                </div>
                <div class="timeline-track">
                    <div class="track-label">PATTERNS</div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { VIB34DIntegratedEngine } from './src/core/Engine.js';
        import { QuantumEngine } from './src/quantum/QuantumEngine.js';
        import { RealHolographicSystem } from './src/holograms/RealHolographicSystem.js';
        import { LLMParameterInterface } from './src/llm/LLMParameterInterface.js';

        class UltimateChoreographer {
            constructor() {
                this.currentSystem = 'faceted';
                this.systems = {
                    faceted: { engine: null, canvases: [], active: true },
                    quantum: { engine: null, canvases: [], active: false },
                    holographic: { engine: null, canvases: [], active: false }
                };

                // Base parameters - NEVER modified by audio
                this.baseParams = {
                    geometry: 1,
                    gridDensity: 15,
                    morphFactor: 1.0,
                    chaos: 0.2,
                    speed: 1.0,
                    hue: 200,
                    intensity: 0.5,
                    saturation: 0.8,
                    rot4dXW: 0.0,
                    rot4dYW: 0.0,
                    rot4dZW: 0.0
                };

                // Audio system
                this.audioContext = null;
                this.audioSource = null;
                this.analyser = null;
                this.audioElement = null;
                this.audioReactive = true;
                this.reactivityStrength = 0.5;

                // Timeline
                this.sequences = [];
                this.currentTime = 0;
                this.duration = 0;
                this.isPlaying = false;

                // Video recording
                this.mediaRecorder = null;
                this.recordedChunks = [];
                this.isRecording = false;
                this.recordingStartTime = 0;
                this.recordingTimer = null;

                // Pattern library
                this.patterns = {
                    'pulse-grow': this.createPulseGrowPattern,
                    'geometry-switch': this.createGeometrySwitchPattern,
                    'color-sweep': this.createColorSweepPattern,
                    'chaos-burst': this.createChaosBurstPattern,
                    'rotation-spin': this.createRotationSpinPattern,
                    'system-cycle': this.createSystemCyclePattern
                };

                this.init();
            }

            async init() {
                console.log('üé¨ Initializing Ultimate Choreographer...');

                // Initialize LLM interface
                this.llmInterface = new LLMParameterInterface();
                this.llmInterface.setApiKey('AIzaSyD1dHwFcwVxg6r-Lt8I7U6CgznDfwn4GeI');
                console.log('‚úÖ LLM Interface initialized');

                await this.initCanvases();
                await this.initCurrentSystem();
                this.setupUI();
                this.setupAudio();

                document.getElementById('loading-indicator').classList.add('hidden');
                console.log('‚úÖ Choreographer ready!');
            }

            async initCanvases() {
                // Canvases are now created dynamically per system
                // No pre-creation needed
            }

            async initCurrentSystem() {
                // CRITICAL: Only initialize the active system to save resources
                await this.createSystem(this.currentSystem);
            }

            async createSystem(systemName) {
                console.log(`üîß Creating ${systemName} system...`);

                const sys = this.systems[systemName];

                // Prevent console spam from visualizers
                const originalLog = console.log;
                const logThrottle = {};
                console.log = (...args) => {
                    const msg = args.join(' ');
                    const key = msg.substring(0, 50);
                    const now = Date.now();
                    if (!logThrottle[key] || now - logThrottle[key] > 1000) {
                        logThrottle[key] = now;
                        originalLog.apply(console, args);
                    }
                };

                // Destroy existing engine if present
                if (sys.engine) {
                    await this.destroySystem(systemName);
                }

                // CRITICAL: Create canvases with correct IDs for each system
                const stageContainer = document.getElementById('stage-container');
                stageContainer.innerHTML = ''; // Clear old canvases

                const width = window.innerWidth;
                const height = window.innerHeight;

                // Define canvas IDs for each system type
                const canvasIds = {
                    faceted: ['background-canvas', 'shadow-canvas', 'content-canvas', 'highlight-canvas', 'accent-canvas'],
                    quantum: ['quantum-background-canvas', 'quantum-shadow-canvas', 'quantum-content-canvas', 'quantum-highlight-canvas', 'quantum-accent-canvas'],
                    holographic: ['holo-background-canvas', 'holo-shadow-canvas', 'holo-content-canvas', 'holo-highlight-canvas', 'holo-accent-canvas']
                };

                // Create canvases
                const ids = canvasIds[systemName];
                ids.forEach(id => {
                    const canvas = document.createElement('canvas');
                    canvas.id = id;
                    canvas.width = width;
                    canvas.height = height;
                    canvas.style.position = 'absolute';
                    canvas.style.top = '0';
                    canvas.style.left = '0';
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                    stageContainer.appendChild(canvas);
                    sys.canvases.push(canvas);
                });

                console.log(`‚úÖ Created ${ids.length} canvases for ${systemName}`);

                // Wait a frame for canvases to be fully laid out
                await new Promise(resolve => requestAnimationFrame(resolve));

                // Create new engine
                try {
                    if (systemName === 'faceted') {
                        sys.engine = new VIB34DIntegratedEngine();
                        // VIB34DIntegratedEngine.init() is called in constructor
                        this.updateSystemParameters(sys.engine);
                    } else if (systemName === 'quantum') {
                        sys.engine = new QuantumEngine();
                        // QuantumEngine.init() is called in constructor
                        this.updateSystemParameters(sys.engine);
                    } else if (systemName === 'holographic') {
                        // Create holographic engine normally (canvases exist now)
                        sys.engine = new RealHolographicSystem();

                        // CRITICAL: Disable ALL built-in audio reactivity to prevent conflicts with choreographer MP3 audio
                        sys.engine.audioEnabled = false;
                        sys.engine.audioContext = null;
                        sys.engine.analyser = null;
                        sys.engine.frequencyData = null;
                        sys.engine.audioData = { bass: 0, mid: 0, high: 0 };

                        // Override audio methods to prevent them from running
                        sys.engine.initAudio = () => { console.log('üö´ Holographic initAudio blocked by choreographer'); };
                        sys.engine.updateAudio = () => {}; // Silent block, runs every frame
                        sys.engine.disableAudio = () => {};

                        // Disable audio reactivity grid (this was overriding choreographer parameters!)
                        sys.engine.applyAudioReactivityGrid = () => {};

                        this.updateSystemParameters(sys.engine);
                    }

                    if (sys.engine && sys.engine.setActive) {
                        sys.engine.setActive(true);
                    }

                    console.log(`‚úÖ ${systemName} system created with ${sys.engine.visualizers ? sys.engine.visualizers.length : 0} visualizers`);
                } catch (error) {
                    console.error(`‚ùå Failed to create ${systemName}:`, error);
                    console.error('Error details:', error.stack);
                } finally {
                    // Restore original console.log
                    console.log = originalLog;
                }
            }

            async switchSystem(systemName) {
                if (systemName === this.currentSystem) return;

                console.log(`üîÑ Switching from ${this.currentSystem} to ${systemName}`);

                // CRITICAL: Properly destroy old system to free GPU resources (mobile performance)
                await this.destroySystem(this.currentSystem);

                // Create new system (this will also create new canvases)
                this.currentSystem = systemName;
                await this.createSystem(systemName);

                // Update UI
                document.querySelectorAll('.system-pill').forEach(pill => {
                    pill.classList.toggle('active', pill.dataset.system === systemName);
                });

                console.log(`‚úÖ Switched to ${systemName}`);
            }

            async destroySystem(systemName) {
                const sys = this.systems[systemName];

                console.log(`üóëÔ∏è Destroying ${systemName} system...`);

                // Deactivate engine
                if (sys.engine) {
                    if (sys.engine.setActive) {
                        sys.engine.setActive(false);
                    }

                    // Destroy all visualizers and their WebGL contexts
                    if (sys.engine.visualizers && Array.isArray(sys.engine.visualizers)) {
                        sys.engine.visualizers.forEach(viz => {
                            if (viz.gl) {
                                // Lose WebGL context to free GPU memory
                                const ext = viz.gl.getExtension('WEBGL_lose_context');
                                if (ext) ext.loseContext();
                            }
                        });
                        sys.engine.visualizers = [];
                    }

                    // Clear engine reference
                    sys.engine = null;
                }

                // Clear canvas references
                sys.canvases = [];

                // Canvases will be removed when stageContainer.innerHTML = '' is called in createSystem

                console.log(`‚úÖ ${systemName} destroyed`);
            }

            updateSystemParameters(engine) {
                if (!engine) return;

                // Apply all base parameters to the engine
                Object.entries(this.baseParams).forEach(([param, value]) => {
                    if (engine.parameterManager && engine.parameterManager.setParameter) {
                        engine.parameterManager.setParameter(param, value);
                    } else if (engine.updateParameter) {
                        engine.updateParameter(param, value);
                    }
                });
            }

            setParameter(param, value) {
                // Update base parameter
                this.baseParams[param] = value;

                // Update active engine's parameter manager
                const sys = this.systems[this.currentSystem];
                if (sys.engine) {
                    if (sys.engine.parameterManager && sys.engine.parameterManager.setParameter) {
                        sys.engine.parameterManager.setParameter(param, value);
                    } else if (sys.engine.updateParameter) {
                        sys.engine.updateParameter(param, value);
                    }

                    // Force immediate update to visualizers
                    if (sys.engine.updateVisualizers) {
                        sys.engine.updateVisualizers();
                    }
                }

                // If audio reactivity is active, force a render cycle
                // This ensures the new base parameter is immediately visible
                if (this.audioReactivityEnabled && this.audioData) {
                    this.updateVisualizers();
                }
            }

            setupUI() {
                // System switching
                document.querySelectorAll('.system-pill').forEach(pill => {
                    pill.addEventListener('click', () => {
                        this.switchSystem(pill.dataset.system);
                    });
                });

                // Parameter controls
                const controls = [
                    { slider: 'geometry-select', param: 'geometry', display: null, isSelect: true },
                    { slider: 'density-slider', param: 'gridDensity', display: 'density-val' },
                    { slider: 'morph-slider', param: 'morphFactor', display: 'morph-val' },
                    { slider: 'chaos-slider', param: 'chaos', display: 'chaos-val' },
                    { slider: 'speed-slider', param: 'speed', display: 'speed-val' },
                    { slider: 'rot4d-xw-slider', param: 'rot4dXW', display: 'rot4d-xw-val' },
                    { slider: 'rot4d-yw-slider', param: 'rot4dYW', display: 'rot4d-yw-val' },
                    { slider: 'rot4d-zw-slider', param: 'rot4dZW', display: 'rot4d-zw-val' }
                ];

                controls.forEach(({ slider, param, display, isSelect }) => {
                    const element = document.getElementById(slider);
                    if (!element) return;

                    element.addEventListener(isSelect ? 'change' : 'input', (e) => {
                        const value = isSelect ? parseInt(e.target.value) : parseFloat(e.target.value);
                        this.setParameter(param, value);
                        if (display) {
                            document.getElementById(display).textContent =
                                param === 'gridDensity' ? Math.floor(value) : value.toFixed(1);
                        }
                    });
                });

                // Color presets
                document.querySelectorAll('.color-preset').forEach(preset => {
                    preset.addEventListener('click', () => {
                        const hue = parseInt(preset.dataset.hue);
                        this.setParameter('hue', hue);
                    });
                });

                // Audio reactivity toggle
                document.getElementById('audio-reactive-toggle').addEventListener('change', (e) => {
                    this.audioReactive = e.target.checked;
                });

                document.getElementById('reactivity-strength-slider').addEventListener('input', (e) => {
                    this.reactivityStrength = parseFloat(e.target.value);
                    document.getElementById('reactivity-strength-val').textContent = this.reactivityStrength.toFixed(1);
                });

                // Pattern library
                document.querySelectorAll('.pattern-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const pattern = item.dataset.pattern;
                        this.applyPattern(pattern);
                    });
                });

                // Timeline UI
                document.getElementById('collapse-btn').addEventListener('click', () => {
                    document.getElementById('choreographer-ui').classList.toggle('collapsed');
                    const btn = document.getElementById('collapse-btn');
                    btn.textContent = btn.textContent === '‚ñº' ? '‚ñ≤' : '‚ñº';
                });

                // Playback controls
                document.getElementById('play-btn').addEventListener('click', () => this.play());
                document.getElementById('pause-btn').addEventListener('click', () => this.pause());
                document.getElementById('stop-btn').addEventListener('click', () => this.stop());

                // Audio file upload
                document.getElementById('audio-file-input').addEventListener('change', (e) => {
                    this.loadAudioFile(e.target.files[0]);
                });

                // Export/Import
                document.getElementById('export-btn').addEventListener('click', () => this.exportChoreography());
                document.getElementById('import-btn').addEventListener('click', () => this.importChoreography());

                // AI Song Analysis
                document.getElementById('analyze-song-btn').addEventListener('click', () => this.analyzeSongWithAI());

                // Video Export and Recording
                document.getElementById('export-video-btn').addEventListener('click', () => this.exportVideoOffline());
                document.getElementById('start-recording-btn').addEventListener('click', () => this.startRecording());
                document.getElementById('stop-recording-btn').addEventListener('click', () => this.stopRecording());

                // LLM Toggle Button
                document.getElementById('toggle-llm-btn').addEventListener('click', () => {
                    const panel = document.getElementById('llm-panel');
                    panel.style.display = panel.style.display === 'flex' ? 'none' : 'flex';
                });
            }

            setupAudio() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 4096;
                this.analyser.smoothingTimeConstant = 0.8;

                // Advanced choreography state
                this.beatHistory = [];
                this.lastBeatTime = 0;
                this.avgBeatInterval = 0;
                this.beatPhase = 0;
                this.energyHistory = [];
                this.energyMomentum = { bass: 0, mid: 0, high: 0 };
                this.peakDetector = { bass: 0, mid: 0, high: 0, energy: 0 };
                this.rhythmicPulse = 0;
                this.choreographyMode = 'dynamic'; // dynamic, wave, pulse, flow, chaos
                this.lastModeChange = 0;

                this.startAudioLoop();
            }

            async loadAudioFile(file) {
                if (!file) return;

                const url = URL.createObjectURL(file);

                // CRITICAL: Resume AudioContext (required for mobile browsers)
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                    console.log('üéµ AudioContext resumed');
                }

                if (this.audioElement) {
                    this.audioElement.pause();
                    this.audioElement.src = '';
                }

                this.audioElement = new Audio(url);
                this.audioElement.crossOrigin = 'anonymous';

                // CRITICAL: Disconnect old source to prevent errors
                if (this.audioSource) {
                    try {
                        this.audioSource.disconnect();
                    } catch (e) {
                        console.warn('Could not disconnect old audio source:', e);
                    }
                }

                // Create new source and connect to destination (speakers)
                try {
                    this.audioSource = this.audioContext.createMediaElementSource(this.audioElement);
                    this.audioSource.connect(this.analyser);
                    this.analyser.connect(this.audioContext.destination);
                    console.log('üéµ Audio connected to speakers');
                } catch (error) {
                    console.error('Failed to create audio source:', error);
                    // If createMediaElementSource fails, try direct playback
                    console.log('üéµ Using direct audio playback (no analysis)');
                }

                this.audioElement.addEventListener('loadedmetadata', () => {
                    this.duration = this.audioElement.duration;
                    console.log(`üéµ Audio loaded: ${this.duration.toFixed(2)}s`);
                });

                this.audioElement.addEventListener('error', (e) => {
                    console.error('Audio element error:', e);
                });
            }

            startAudioLoop() {
                const dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                let lastTime = performance.now();

                const loop = () => {
                    requestAnimationFrame(loop);

                    if (!this.audioReactive || !this.analyser) return;

                    const now = performance.now();
                    const dt = (now - lastTime) / 1000;
                    lastTime = now;

                    this.analyser.getByteFrequencyData(dataArray);

                    // ADVANCED MULTI-BAND FREQUENCY ANALYSIS
                    const bass = this.getFrequencyRange(dataArray, 0, 100) / 255;
                    const lowMid = this.getFrequencyRange(dataArray, 100, 250) / 255;
                    const mid = this.getFrequencyRange(dataArray, 250, 500) / 255;
                    const highMid = this.getFrequencyRange(dataArray, 500, 800) / 255;
                    const high = this.getFrequencyRange(dataArray, 800, 1024) / 255;
                    const energy = (bass * 2 + lowMid + mid + highMid + high) / 6; // Bass weighted

                    // BEAT DETECTION (kick drum detection via bass spike)
                    const beatThreshold = this.peakDetector.bass * 0.7 + 0.3;
                    let isBeat = false;
                    if (bass > beatThreshold && (now - this.lastBeatTime) > 250) {
                        isBeat = true;
                        this.lastBeatTime = now;
                        this.beatHistory.push(now);
                        if (this.beatHistory.length > 8) this.beatHistory.shift();

                        // Calculate tempo from beat intervals
                        if (this.beatHistory.length >= 4) {
                            const intervals = [];
                            for (let i = 1; i < this.beatHistory.length; i++) {
                                intervals.push(this.beatHistory[i] - this.beatHistory[i-1]);
                            }
                            this.avgBeatInterval = intervals.reduce((a,b) => a+b, 0) / intervals.length;
                        }
                    }

                    // RHYTHMIC PULSE (tempo-synced animation phase)
                    if (this.avgBeatInterval > 0) {
                        const timeSinceLastBeat = now - this.lastBeatTime;
                        this.beatPhase = (timeSinceLastBeat / this.avgBeatInterval) % 1;
                        this.rhythmicPulse = Math.sin(this.beatPhase * Math.PI * 2) * 0.5 + 0.5;
                    }

                    // PEAK DETECTION (smooth decay for adaptive thresholds)
                    this.peakDetector.bass = Math.max(this.peakDetector.bass * 0.99, bass);
                    this.peakDetector.mid = Math.max(this.peakDetector.mid * 0.99, mid);
                    this.peakDetector.high = Math.max(this.peakDetector.high * 0.99, high);
                    this.peakDetector.energy = Math.max(this.peakDetector.energy * 0.99, energy);

                    // MOMENTUM (smooth acceleration/deceleration)
                    this.energyMomentum.bass += (bass - this.energyMomentum.bass) * 0.15;
                    this.energyMomentum.mid += (mid - this.energyMomentum.mid) * 0.12;
                    this.energyMomentum.high += (high - this.energyMomentum.high) * 0.18;

                    // ENERGY HISTORY (for dynamic mode switching)
                    this.energyHistory.push(energy);
                    if (this.energyHistory.length > 120) this.energyHistory.shift(); // 2 second window at 60fps

                    // DYNAMIC MODE SWITCHING (based on song intensity)
                    if ((now - this.lastModeChange) > 5000) { // Check every 5 seconds
                        const avgEnergy = this.energyHistory.reduce((a,b) => a+b, 0) / this.energyHistory.length;
                        const energyVariance = this.energyHistory.map(e => Math.abs(e - avgEnergy)).reduce((a,b) => a+b, 0) / this.energyHistory.length;

                        if (avgEnergy > 0.7 && energyVariance > 0.2) {
                            this.choreographyMode = 'chaos';
                        } else if (avgEnergy > 0.5) {
                            this.choreographyMode = 'pulse';
                        } else if (energyVariance > 0.15) {
                            this.choreographyMode = 'dynamic';
                        } else if (avgEnergy < 0.3) {
                            this.choreographyMode = 'flow';
                        } else {
                            this.choreographyMode = 'wave';
                        }

                        this.lastModeChange = now;
                        console.log(`üé≠ Choreography mode: ${this.choreographyMode} (energy=${avgEnergy.toFixed(2)}, variance=${energyVariance.toFixed(2)})`);
                    }

                    // Apply sophisticated choreography
                    this.applyAdvancedChoreography({
                        bass, lowMid, mid, highMid, high, energy,
                        isBeat,
                        beatPhase: this.beatPhase,
                        rhythmicPulse: this.rhythmicPulse,
                        momentum: this.energyMomentum,
                        peaks: this.peakDetector,
                        dt
                    });
                };

                loop();
            }

            getFrequencyRange(dataArray, startIdx, endIdx) {
                let sum = 0;
                for (let i = startIdx; i < endIdx && i < dataArray.length; i++) {
                    sum += dataArray[i];
                }
                return sum / (endIdx - startIdx);
            }

            applyAdvancedChoreography(audio) {
                const strength = this.reactivityStrength;
                const sys = this.systems[this.currentSystem];
                if (!sys.engine) return;

                const engine = sys.engine;
                const mode = this.choreographyMode;

                // Helper to set parameter on any engine type
                const setParam = (param, value) => {
                    if (engine.parameterManager && engine.parameterManager.setParameter) {
                        engine.parameterManager.setParameter(param, value);
                    } else if (engine.updateParameter) {
                        engine.updateParameter(param, value);
                    }
                };

                // MODE-BASED CHOREOGRAPHY FLOWS
                switch (mode) {
                    case 'chaos':
                        this.applyChaosFlow(audio, setParam, strength);
                        break;
                    case 'pulse':
                        this.applyPulseFlow(audio, setParam, strength);
                        break;
                    case 'wave':
                        this.applyWaveFlow(audio, setParam, strength);
                        break;
                    case 'flow':
                        this.applyFlowMode(audio, setParam, strength);
                        break;
                    case 'dynamic':
                    default:
                        this.applyDynamicFlow(audio, setParam, strength);
                        break;
                }
            }

            applyChaosFlow(audio, setParam, strength) {
                // CHAOS MODE: Intense, unpredictable, multi-parameter modulation
                // Perfect for drops, heavy sections, EDM breakdowns

                // Beat-synced chaos bursts
                const chaosBurst = audio.isBeat ? 1.0 : audio.momentum.bass;
                const density = this.baseParams.gridDensity + (audio.bass * 60 * strength) + (chaosBurst * 20);

                // Rapid hue cycling on high frequencies
                const hueShift = audio.high * 180 * strength + audio.rhythmicPulse * 60;
                const hue = (this.baseParams.hue + hueShift) % 360;

                // Morphing driven by mid-range with exponential scaling
                const morph = this.baseParams.morphFactor + (Math.pow(audio.mid, 2) * 1.5 * strength);

                // Chaos parameter maxed out with beat reinforcement
                const chaos = this.baseParams.chaos + (audio.energy * 0.8 * strength) + (audio.isBeat ? 0.2 : 0);

                // Speed bursts on beats, sustained by energy
                const speed = this.baseParams.speed * (1 + audio.energy * 2 * strength) * (audio.isBeat ? 1.5 : 1);

                // Intensity pulses with rhythm
                const intensity = Math.min(1, this.baseParams.intensity * (0.6 + audio.peaks.energy * 0.8 * strength));

                // Saturation follows high-frequency energy
                const saturation = Math.min(1, this.baseParams.saturation * (0.8 + audio.high * 0.5 * strength));

                // 4D ROTATION CHAOS: Each axis gets independent frequency-driven rotation
                const rot4dXW = this.baseParams.rot4dXW + (audio.bass * 4 * strength) + (audio.isBeat ? 1.5 : 0);
                const rot4dYW = this.baseParams.rot4dYW + (audio.mid * 5 * strength) - (audio.lowMid * 2 * strength);
                const rot4dZW = this.baseParams.rot4dZW + (audio.high * 6 * strength) + (audio.rhythmicPulse * 2);

                setParam('gridDensity', Math.floor(density));
                setParam('hue', Math.floor(hue));
                setParam('morphFactor', Math.min(2, morph));
                setParam('chaos', Math.min(1, chaos));
                setParam('speed', Math.min(3, speed));
                setParam('intensity', intensity);
                setParam('saturation', saturation);
                setParam('rot4dXW', Math.max(-6.28, Math.min(6.28, rot4dXW)));
                setParam('rot4dYW', Math.max(-6.28, Math.min(6.28, rot4dYW)));
                setParam('rot4dZW', Math.max(-6.28, Math.min(6.28, rot4dZW)));
            }

            applyPulseFlow(audio, setParam, strength) {
                // PULSE MODE: Rhythmic, beat-locked, pumping motion
                // Perfect for house, techno, hip-hop with strong beats

                // Density expands/contracts with rhythm
                const pulseFactor = 0.7 + audio.rhythmicPulse * 0.6; // 0.7-1.3 range
                const density = this.baseParams.gridDensity * pulseFactor + (audio.bass * 40 * strength);

                // Hue locked to beat phase (creates strobing color changes)
                const beatHueShift = Math.floor(audio.beatPhase * 4) * 90; // Snaps to 0, 90, 180, 270
                const hue = (this.baseParams.hue + beatHueShift + audio.lowMid * 30 * strength) % 360;

                // Morph pulses in sync with tempo
                const morph = this.baseParams.morphFactor * (0.8 + audio.rhythmicPulse * 0.4);

                // Sharp intensity spikes on beats
                const beatIntensity = audio.isBeat ? 1.0 : (0.6 + audio.momentum.bass * 0.4);
                const intensity = Math.min(1, this.baseParams.intensity * beatIntensity);

                // Speed modulated by rhythm
                const speed = this.baseParams.speed * (0.9 + audio.rhythmicPulse * 0.3 * strength);

                // Saturation breathes with mid-range
                const saturation = Math.min(1, this.baseParams.saturation * (0.85 + audio.mid * 0.3 * strength));

                // 4D ROTATION PULSE: Tempo-locked rotations creating rhythmic 4D tumbling
                const rot4dXW = this.baseParams.rot4dXW + (audio.rhythmicPulse * 3 * strength);
                const rot4dYW = this.baseParams.rot4dYW + (Math.sin(audio.beatPhase * Math.PI) * 2 * strength);
                const rot4dZW = this.baseParams.rot4dZW + (audio.isBeat ? 0.8 : 0) + (audio.bass * 1.5 * strength);

                setParam('gridDensity', Math.floor(density));
                setParam('hue', Math.floor(hue));
                setParam('morphFactor', Math.min(2, morph));
                setParam('intensity', intensity);
                setParam('speed', Math.min(3, speed));
                setParam('saturation', saturation);
                setParam('rot4dXW', Math.max(-6.28, Math.min(6.28, rot4dXW)));
                setParam('rot4dYW', Math.max(-6.28, Math.min(6.28, rot4dYW)));
                setParam('rot4dZW', Math.max(-6.28, Math.min(6.28, rot4dZW)));
            }

            applyWaveFlow(audio, setParam, strength) {
                // WAVE MODE: Smooth, flowing, oceanic motion
                // Perfect for ambient, chill, progressive builds

                // Gentle density waves
                const wavePhase = performance.now() * 0.0003; // Slow wave
                const waveModulation = Math.sin(wavePhase) * 0.3 + Math.sin(wavePhase * 1.7) * 0.2;
                const density = this.baseParams.gridDensity + (audio.momentum.bass * 25 * strength) + (waveModulation * 15);

                // Smooth hue rotation with audio influence
                const hueWave = Math.sin(wavePhase * 0.8) * 45;
                const hue = (this.baseParams.hue + hueWave + audio.mid * 20 * strength) % 360;

                // Morph follows energy with momentum smoothing
                const morph = this.baseParams.morphFactor + (audio.momentum.mid * 0.8 * strength);

                // Chaos creates organic variation
                const chaos = this.baseParams.chaos + (Math.sin(wavePhase * 2.3) * 0.2 + 0.2) * (audio.energy * strength);

                // Smooth speed variation
                const speed = this.baseParams.speed * (0.9 + audio.momentum.high * 0.4 * strength);

                // Intensity ebbs and flows
                const intensity = Math.min(1, this.baseParams.intensity * (0.75 + audio.momentum.mid * 0.4 * strength + Math.sin(wavePhase * 1.5) * 0.15));

                // 4D ROTATION WAVE: Smooth sinusoidal tumbling through 4D space
                const rot4dXW = this.baseParams.rot4dXW + (Math.sin(wavePhase * 1.2) * 1.5 * strength) + (audio.momentum.bass * 0.5);
                const rot4dYW = this.baseParams.rot4dYW + (Math.cos(wavePhase * 0.9) * 1.8 * strength) + (audio.momentum.mid * 0.6);
                const rot4dZW = this.baseParams.rot4dZW + (Math.sin(wavePhase * 1.5 + Math.PI/3) * 1.2 * strength) + (audio.momentum.high * 0.4);

                setParam('gridDensity', Math.floor(density));
                setParam('hue', Math.floor(hue));
                setParam('morphFactor', Math.min(2, morph));
                setParam('chaos', Math.min(1, chaos));
                setParam('speed', Math.min(3, speed));
                setParam('intensity', intensity);
                setParam('rot4dXW', Math.max(-6.28, Math.min(6.28, rot4dXW)));
                setParam('rot4dYW', Math.max(-6.28, Math.min(6.28, rot4dYW)));
                setParam('rot4dZW', Math.max(-6.28, Math.min(6.28, rot4dZW)));
            }

            applyFlowMode(audio, setParam, strength) {
                // FLOW MODE: Gentle, meditative, minimal reactivity
                // Perfect for quiet sections, intros, ambient passages

                // Minimal density changes
                const density = this.baseParams.gridDensity + (audio.bass * 10 * strength);

                // Slow hue drift
                const hue = (this.baseParams.hue + audio.lowMid * 15 * strength) % 360;

                // Subtle morphing
                const morph = this.baseParams.morphFactor + (audio.mid * 0.3 * strength);

                // Low chaos for calm visuals
                const chaos = this.baseParams.chaos * (0.5 + audio.energy * 0.3 * strength);

                // Consistent slow speed
                const speed = this.baseParams.speed * (0.85 + audio.high * 0.2 * strength);

                // Gentle intensity variation
                const intensity = Math.min(1, this.baseParams.intensity * (0.8 + audio.energy * 0.25 * strength));

                // High saturation for rich colors
                const saturation = Math.min(1, this.baseParams.saturation * (0.9 + audio.mid * 0.15 * strength));

                // 4D ROTATION FLOW: Slow, meditative drift through hyperspace
                const flowPhase = performance.now() * 0.0001; // Very slow
                const rot4dXW = this.baseParams.rot4dXW + (Math.sin(flowPhase) * 0.5 * strength) + (audio.bass * 0.2);
                const rot4dYW = this.baseParams.rot4dYW + (Math.cos(flowPhase * 1.3) * 0.6 * strength) + (audio.mid * 0.15);
                const rot4dZW = this.baseParams.rot4dZW + (Math.sin(flowPhase * 0.7) * 0.4 * strength) + (audio.high * 0.1);

                setParam('gridDensity', Math.floor(density));
                setParam('hue', Math.floor(hue));
                setParam('morphFactor', Math.min(2, morph));
                setParam('chaos', Math.min(1, chaos));
                setParam('speed', Math.min(3, speed));
                setParam('intensity', intensity);
                setParam('saturation', saturation);
                setParam('rot4dXW', Math.max(-6.28, Math.min(6.28, rot4dXW)));
                setParam('rot4dYW', Math.max(-6.28, Math.min(6.28, rot4dYW)));
                setParam('rot4dZW', Math.max(-6.28, Math.min(6.28, rot4dZW)));
            }

            applyDynamicFlow(audio, setParam, strength) {
                // DYNAMIC MODE: Balanced, responsive, musical
                // Automatically balances all parameters based on frequency content

                // Bass creates density, mid creates detail
                const density = this.baseParams.gridDensity + (audio.bass * 35 * strength) + (audio.mid * 15 * strength);

                // Multi-band hue modulation
                const bassHue = audio.bass * 30;
                const midHue = audio.mid * 45;
                const highHue = audio.high * 60;
                const hue = (this.baseParams.hue + bassHue + midHue + highHue * strength) % 360;

                // Morph responds to mid-range with beat reinforcement
                const morph = this.baseParams.morphFactor + (audio.mid * 1.0 * strength) + (audio.isBeat ? 0.3 : 0);

                // Chaos from high frequencies and energy variance
                const chaos = this.baseParams.chaos + (audio.highMid * 0.6 * strength) + (audio.peaks.energy - audio.energy) * 0.3;

                // Speed modulated by rhythm and high energy
                const speed = this.baseParams.speed * (1 + audio.high * 1.2 * strength) * (audio.isBeat ? 1.2 : 1);

                // Intensity follows overall energy with momentum
                const intensity = Math.min(1, this.baseParams.intensity * (0.7 + audio.momentum.mid * 0.5 * strength + audio.energy * 0.3));

                // Saturation enhances on high energy
                const saturation = Math.min(1, this.baseParams.saturation * (0.85 + audio.energy * 0.3 * strength));

                // 4D ROTATION DYNAMIC: Each frequency band controls independent axis
                const rot4dXW = this.baseParams.rot4dXW + (audio.bass * 2.5 * strength) + (audio.momentum.bass * 1.0);
                const rot4dYW = this.baseParams.rot4dYW + (audio.mid * 3.0 * strength) + (audio.isBeat ? 0.5 : 0);
                const rot4dZW = this.baseParams.rot4dZW + (audio.high * 3.5 * strength) + (audio.momentum.high * 0.8);

                setParam('gridDensity', Math.floor(density));
                setParam('hue', Math.floor(hue));
                setParam('morphFactor', Math.min(2, morph));
                setParam('chaos', Math.min(1, chaos));
                setParam('speed', Math.min(3, speed));
                setParam('intensity', intensity);
                setParam('saturation', saturation);
                setParam('rot4dXW', Math.max(-6.28, Math.min(6.28, rot4dXW)));
                setParam('rot4dYW', Math.max(-6.28, Math.min(6.28, rot4dYW)));
                setParam('rot4dZW', Math.max(-6.28, Math.min(6.28, rot4dZW)));
            }

            async analyzeSongWithAI() {
                const apiKey = document.getElementById('gemini-api-key').value.trim();
                const statusEl = document.getElementById('ai-analysis-status');

                if (!apiKey) {
                    statusEl.textContent = '‚ö†Ô∏è Please enter Gemini API key';
                    statusEl.style.color = '#ff0080';
                    return;
                }

                if (!this.audioElement) {
                    statusEl.textContent = '‚ö†Ô∏è Please load an audio file first';
                    statusEl.style.color = '#ff0080';
                    return;
                }

                statusEl.textContent = 'ü§ñ Analyzing song structure with AI...';
                statusEl.style.color = '#00ffff';

                try {
                    // Analyze the audio data we have
                    const songAnalysis = await this.getAIChoreographyInstructions(apiKey);

                    console.log('üé≠ AI Choreography Instructions:', songAnalysis);

                    // Apply AI choreography instructions
                    this.applyAIChoreography(songAnalysis);

                    statusEl.textContent = `‚úÖ AI Analysis complete! ${songAnalysis.sections?.length || 0} sections detected`;
                    statusEl.style.color = '#00ff00';

                } catch (error) {
                    console.error('AI Analysis failed:', error);
                    statusEl.textContent = `‚ùå AI Analysis failed: ${error.message}`;
                    statusEl.style.color = '#ff0000';
                }
            }

            async getAIChoreographyInstructions(apiKey) {
                const songDuration = this.duration || 180; // Default 3 minutes if not loaded yet
                const currentBPM = this.avgBeatInterval > 0 ? (60000 / this.avgBeatInterval).toFixed(0) : 120;

                const prompt = `You are an EXTREME music video choreographer AI specializing in 4D mathematical visualizations synchronized to musical patterns. Create a HIGHLY DETAILED choreography plan with EXTREME parameter values and BEAT-SYNCHRONIZED changes.

Song Information:
- Duration: ${songDuration.toFixed(1)} seconds
- Detected BPM: ${currentBPM}

üéØ CRITICAL CHOREOGRAPHY RULES:
1. **EXTREME PARAMETER VALUES**: Use the FULL parameter ranges! Don't be conservative!
   - 4D Rotations: Use ¬±5 to ¬±6 radians for drops (EXTREME spinning)
   - Grid Density: 80-95 for drops, 5-15 for calm sections
   - Chaos: 0.8-0.95 for chaotic sections, 0-0.2 for calm
   - Speed: 2-3 for intense, 0.3-0.7 for calm

2. **BEAT-SYNCHRONIZED 4D ROTATIONS**:
   - Map each 4D axis to different musical elements:
     * rot4dXW: Bass frequencies (¬±4 to ¬±6 for drops)
     * rot4dYW: Mid/melody frequencies (¬±3 to ¬±5 for melodic sections)
     * rot4dZW: High frequencies (¬±2 to ¬±4 for percussion)
   - Use OPPOSITE rotations (positive/negative) for visual contrast
   - Example Drop: {"rot4dXW": 5.5, "rot4dYW": -4.8, "rot4dZW": 4.2}

3. **COLOR PATTERNS TO BEAT**:
   - Intro: Cool blues/cyans (hue: 180-210)
   - Build-Up: Shifting purples (hue: 240-280)
   - Drop/Chorus: Hot magentas/reds (hue: 300-360 or 0-30)
   - Breakdown: Calm greens (hue: 120-160)
   - Outro: Return to blues (hue: 190-220)

4. **MELODIC 4D MAPPING**:
   - High melody notes ‚Üí Increase rot4dYW (positive direction)
   - Low melody notes ‚Üí Decrease rot4dYW (negative direction)
   - Chord changes ‚Üí Sudden rot4dZW shifts
   - Bassline ‚Üí Strong rot4dXW oscillation

5. **PATTERNED DYNAMIC RESPONSES**:
   - Every 4 beats: Geometry should pulse with gridDensity ¬±30
   - Every 8 beats: Consider geometry type change
   - Every 16 beats: Major hue shift (¬±60 degrees)
   - Drops: ALL parameters at maximum (gridDensity 90+, chaos 0.9+, speed 2.5+, extreme rotations)

Return this JSON structure (ONLY JSON, no markdown):

{
  "songTitle": "Estimated title based on structure",
  "bpm": ${currentBPM},
  "energy": "high/extreme",
  "genre": "Estimated genre",
  "sections": [
    {
      "name": "Section name",
      "startTime": 0.0,
      "duration": 16.0,
      "system": "faceted/quantum/holographic",
      "geometry": 0-7,
      "choreographyMode": "chaos/pulse/wave/flow/dynamic",
      "parameters": {
        "gridDensity": 5-100,
        "morphFactor": 0-2,
        "chaos": 0-1,
        "speed": 0.1-3,
        "hue": 0-360,
        "intensity": 0-1,
        "saturation": 0-1,
        "rot4dXW": -6.28 to 6.28,
        "rot4dYW": -6.28 to 6.28,
        "rot4dZW": -6.28 to 6.28
      },
      "description": "Musical events and why these parameters"
    }
  ],
  "recommendations": "Strategy explanation"
}

SYSTEM USAGE:
- faceted: Minimal/ambient (intros, quiet verses)
- quantum: Complex/layered (busy sections, builds)
- holographic: MAXIMUM IMPACT (drops, climaxes) - ALWAYS use for drops!

MODE USAGE:
- chaos: Drops, intense moments (extreme random variation)
- pulse: Strong rhythmic sections (beat-locked pulsing)
- wave: Smooth builds (wavelike motion)
- flow: Calm sections (gentle movement)
- dynamic: Balanced auto-switching

Create 6-10 sections covering the full ${songDuration.toFixed(0)} seconds. Use EXTREME values! Make it VISUALLY INTENSE!`;

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: prompt
                            }]
                        }]
                    })
                });

                if (!response.ok) {
                    throw new Error(`Gemini API error: ${response.status}`);
                }

                const data = await response.json();
                const text = data.candidates[0].content.parts[0].text;

                // Extract JSON from response (remove markdown if present)
                let jsonText = text.trim();
                if (jsonText.startsWith('```json')) {
                    jsonText = jsonText.replace(/```json\n/, '').replace(/\n```$/, '');
                } else if (jsonText.startsWith('```')) {
                    jsonText = jsonText.replace(/```\n/, '').replace(/\n```$/, '');
                }

                return JSON.parse(jsonText);
            }

            applyAIChoreography(analysis) {
                console.log('üé≠ Applying AI Choreography:', analysis);

                // Clear existing sequences
                this.sequences = [];

                // Create choreography sequences from AI analysis
                if (analysis.sections && Array.isArray(analysis.sections)) {
                    analysis.sections.forEach((section, index) => {
                        console.log(`üé¨ Section ${index + 1}: ${section.name} (${section.startTime}s, ${section.system})`);

                        // Create a timed sequence for this section
                        this.sequences.push({
                            name: section.name,
                            startTime: section.startTime,
                            duration: section.duration,
                            system: section.system,
                            geometry: section.geometry,
                            mode: section.choreographyMode,
                            parameters: section.parameters,
                            active: false
                        });
                    });

                    // Start monitoring for sequence activation
                    this.startSequenceMonitoring();

                    console.log(`‚úÖ Applied ${analysis.sections.length} AI-generated sequences`);
                }

                // Display recommendations
                if (analysis.recommendations) {
                    console.log(`üí° AI Recommendations: ${analysis.recommendations}`);
                }
            }

            startSequenceMonitoring() {
                // Monitor audio playback and activate sequences at correct times
                if (this.sequenceMonitorInterval) {
                    clearInterval(this.sequenceMonitorInterval);
                }

                // Show AI section display
                document.getElementById('ai-section-display').style.display = 'block';

                this.sequenceMonitorInterval = setInterval(() => {
                    if (!this.audioElement || !this.isPlaying) return;

                    const currentTime = this.audioElement.currentTime;
                    let activeSection = null;
                    let nextSection = null;

                    this.sequences.forEach((seq, index) => {
                        const inSequence = currentTime >= seq.startTime && currentTime < (seq.startTime + seq.duration);

                        if (inSequence) {
                            activeSection = seq;

                            if (!seq.active) {
                                // Activate sequence
                                console.log(`üé¨ Activating sequence: ${seq.name} at ${currentTime.toFixed(1)}s`);
                                seq.active = true;

                                // Switch system if needed
                                if (seq.system && seq.system !== this.currentSystem) {
                                    this.switchSystem(seq.system);
                                }

                                // Apply parameters
                                if (seq.parameters) {
                                    Object.entries(seq.parameters).forEach(([param, value]) => {
                                        this.setParameter(param, value);
                                        this.baseParams[param] = value; // Update base params
                                    });
                                }

                                // Set choreography mode
                                if (seq.mode) {
                                    this.choreographyMode = seq.mode;
                                    console.log(`üé≠ Choreography mode: ${seq.mode}`);
                                }

                                // Set geometry
                                if (seq.geometry !== undefined) {
                                    this.setParameter('geometry', seq.geometry);
                                }
                            }

                            // Find next section
                            if (index + 1 < this.sequences.length) {
                                nextSection = this.sequences[index + 1];
                            }

                        } else if (!inSequence && seq.active) {
                            // Deactivate sequence
                            seq.active = false;
                        }
                    });

                    // Update UI Display
                    this.updateSectionDisplay(activeSection, nextSection, currentTime);

                }, 100); // Check every 100ms
            }

            updateSectionDisplay(activeSection, nextSection, currentTime) {
                const display = document.getElementById('ai-section-display');

                if (!activeSection) {
                    document.getElementById('current-section').textContent = 'No section active';
                    document.getElementById('section-system').textContent = '-';
                    document.getElementById('section-mode').textContent = '-';
                    document.getElementById('section-geometry').textContent = '-';
                    document.getElementById('section-time').textContent = '0:00';
                    document.getElementById('section-duration').textContent = '0:00';
                    document.getElementById('section-progress-fill').style.width = '0%';
                    document.getElementById('next-section-name').textContent = '-';
                    document.getElementById('next-section-time').textContent = '0s';
                    return;
                }

                // Update current section info
                document.getElementById('current-section').textContent = activeSection.name;
                document.getElementById('section-system').textContent = activeSection.system || '-';
                document.getElementById('section-mode').textContent = activeSection.mode || '-';

                const geometryNames = ['Tetrahedron', 'Hypercube', 'Sphere', 'Torus', 'Klein Bottle', 'Fractal', 'Wave', 'Crystal'];
                document.getElementById('section-geometry').textContent = geometryNames[activeSection.geometry] || '-';

                // Update time display
                const sectionTime = currentTime - activeSection.startTime;
                const timeStr = `${Math.floor(sectionTime / 60)}:${Math.floor(sectionTime % 60).toString().padStart(2, '0')}`;
                const durationStr = `${Math.floor(activeSection.duration / 60)}:${Math.floor(activeSection.duration % 60).toString().padStart(2, '0')}`;
                document.getElementById('section-time').textContent = timeStr;
                document.getElementById('section-duration').textContent = durationStr;

                // Update progress bar
                const progress = ((currentTime - activeSection.startTime) / activeSection.duration) * 100;
                document.getElementById('section-progress-fill').style.width = `${Math.min(100, progress)}%`;

                // Update next section info
                if (nextSection) {
                    document.getElementById('next-section-name').textContent = nextSection.name;
                    const timeUntilNext = Math.max(0, nextSection.startTime - currentTime);
                    document.getElementById('next-section-time').textContent = `${timeUntilNext.toFixed(0)}s`;
                } else {
                    document.getElementById('next-section-name').textContent = 'End';
                    document.getElementById('next-section-time').textContent = '-';
                }
            }

            async play() {
                if (!this.audioElement) {
                    console.warn('‚ö†Ô∏è No audio file loaded. Please upload an MP3 file first.');
                    return;
                }

                // CRITICAL: Resume AudioContext on user interaction (mobile requirement)
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                    console.log('üéµ AudioContext resumed on play');
                }

                try {
                    await this.audioElement.play();
                    this.isPlaying = true;
                    console.log('‚ñ∂Ô∏è Audio playing');
                } catch (error) {
                    console.error('Failed to play audio:', error);
                    alert('Failed to play audio. Please try again or check browser permissions.');
                }
            }

            pause() {
                if (this.audioElement) {
                    this.audioElement.pause();
                    this.isPlaying = false;
                }
            }

            stop() {
                if (this.audioElement) {
                    this.audioElement.pause();
                    this.audioElement.currentTime = 0;
                    this.isPlaying = false;
                }
            }

            // Pattern creation methods
            createPulseGrowPattern(startTime, duration) {
                return {
                    type: 'pulse-grow',
                    startTime,
                    duration,
                    apply: (t) => {
                        const phase = (t - startTime) / duration;
                        const pulse = Math.sin(phase * Math.PI * 8) * 3;
                        this.setParameter('gridDensity', this.baseParams.gridDensity + pulse);
                    }
                };
            }

            createGeometrySwitchPattern(startTime, duration) {
                return {
                    type: 'geometry-switch',
                    startTime,
                    duration,
                    apply: (t) => {
                        const phase = Math.floor((t - startTime) / (duration / 8));
                        this.setParameter('geometry', phase % 8);
                    }
                };
            }

            createColorSweepPattern(startTime, duration) {
                return {
                    type: 'color-sweep',
                    startTime,
                    duration,
                    apply: (t) => {
                        const phase = (t - startTime) / duration;
                        this.setParameter('hue', phase * 360);
                    }
                };
            }

            createChaosBurstPattern(startTime, duration) {
                return {
                    type: 'chaos-burst',
                    startTime,
                    duration,
                    apply: (t) => {
                        const phase = (t - startTime) / duration;
                        this.setParameter('chaos', Math.sin(phase * Math.PI) * 0.8);
                    }
                };
            }

            createRotationSpinPattern(startTime, duration) {
                return {
                    type: 'rotation-spin',
                    startTime,
                    duration,
                    apply: (t) => {
                        const phase = (t - startTime) / duration;
                        this.setParameter('rot4dXW', Math.sin(phase * Math.PI * 4) * 3);
                        this.setParameter('rot4dYW', Math.cos(phase * Math.PI * 4) * 3);
                    }
                };
            }

            createSystemCyclePattern(startTime, duration) {
                return {
                    type: 'system-cycle',
                    startTime,
                    duration,
                    apply: async (t) => {
                        const phase = Math.floor((t - startTime) / (duration / 3));
                        const systems = ['faceted', 'quantum', 'holographic'];
                        await this.switchSystem(systems[phase % 3]);
                    }
                };
            }

            applyPattern(patternName) {
                if (!this.patterns[patternName]) return;

                const pattern = this.patterns[patternName].call(this, this.currentTime, 8);
                this.sequences.push(pattern);

                console.log(`‚ú® Applied pattern: ${patternName}`);
            }

            exportChoreography() {
                const data = {
                    version: '1.0',
                    duration: this.duration,
                    sequences: this.sequences,
                    baseParams: this.baseParams
                };

                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `choreography-${Date.now()}.json`;
                a.click();

                console.log('üíæ Choreography exported');
            }

            importChoreography() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'application/json';

                input.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const text = await file.text();
                    const data = JSON.parse(text);

                    this.sequences = data.sequences || [];
                    this.baseParams = data.baseParams || this.baseParams;
                    this.duration = data.duration || 0;

                    console.log('üìÇ Choreography imported');
                });

                input.click();
            }

            // OFFLINE VIDEO EXPORT (NON-REALTIME RENDERING)
            async exportVideoOffline() {
                try {
                    const statusEl = document.getElementById('export-status');
                    const progressBar = document.getElementById('export-progress');
                    const progressFill = document.getElementById('export-progress-fill');

                    // Check prerequisites
                    if (!this.audioElement) {
                        statusEl.textContent = '‚ùå Load an audio file first!';
                        statusEl.style.color = '#f00';
                        return;
                    }

                    if (this.sequences.length === 0) {
                        statusEl.textContent = '‚ùå Generate AI choreography first!';
                        statusEl.style.color = '#f00';
                        return;
                    }

                    statusEl.textContent = 'üé¨ Starting automated video export...';
                    statusEl.style.color = '#0ff';
                    progressBar.style.display = 'block';
                    progressFill.style.width = '10%';

                    // Method: Auto-play with MediaRecorder in accelerated mode
                    // This will play through the choreography automatically and record it
                    await this.autoPlayAndRecord();

                } catch (error) {
                    console.error('Export error:', error);
                    const statusEl = document.getElementById('export-status');
                    statusEl.textContent = `‚ùå Export failed: ${error.message}`;
                    statusEl.style.color = '#f00';
                }
            }

            async autoPlayAndRecord() {
                const statusEl = document.getElementById('export-status');
                const progressBar = document.getElementById('export-progress');
                const progressFill = document.getElementById('export-progress-fill');

                statusEl.textContent = 'üé• Auto-recording will start in 2 seconds...';
                await new Promise(resolve => setTimeout(resolve, 2000));

                // Start recording
                await this.startRecording();

                statusEl.textContent = '‚ñ∂Ô∏è Auto-playing choreography...';
                progressFill.style.width = '30%';

                // Start playback from beginning
                this.audioElement.currentTime = 0;
                await this.play();

                // Monitor progress
                const duration = this.audioElement.duration;
                const progressInterval = setInterval(() => {
                    if (this.audioElement) {
                        const progress = (this.audioElement.currentTime / duration) * 100;
                        progressFill.style.width = `${30 + (progress * 0.6)}%`; // 30% to 90%
                        statusEl.textContent = `üé¨ Recording... ${progress.toFixed(0)}% complete`;
                    }
                }, 500);

                // Wait for audio to finish
                await new Promise(resolve => {
                    this.audioElement.onended = () => {
                        clearInterval(progressInterval);
                        resolve();
                    };
                });

                // Stop recording
                this.stopRecording();

                progressFill.style.width = '100%';
                statusEl.textContent = '‚úÖ Video export complete! Check your downloads.';
                statusEl.style.color = '#0f0';

                setTimeout(() => {
                    progressBar.style.display = 'none';
                    statusEl.textContent = '';
                }, 5000);
            }

            updateChoreographyAtTime(currentTime) {
                // Find and apply active section at this time
                let activeSection = null;

                this.sequences.forEach(seq => {
                    const inSequence = currentTime >= seq.startTime && currentTime < (seq.startTime + seq.duration);

                    if (inSequence) {
                        activeSection = seq;

                        // Switch system if needed
                        if (seq.system && seq.system !== this.currentSystem) {
                            this.switchSystem(seq.system);
                        }

                        // Apply parameters
                        if (seq.parameters) {
                            Object.entries(seq.parameters).forEach(([param, value]) => {
                                this.setParameter(param, value);
                                this.baseParams[param] = value;
                            });
                        }

                        // Set choreography mode
                        if (seq.mode) {
                            this.choreographyMode = seq.mode;
                        }

                        // Set geometry
                        if (seq.geometry !== undefined) {
                            this.setParameter('geometry', seq.geometry);
                        }
                    }
                });
            }

            // VIDEO RECORDING METHODS (REALTIME)
            async startRecording() {
                try {
                    // Get the stage container
                    const stageContainer = document.getElementById('stage-container');

                    // Create a composite canvas for recording
                    this.recordingCanvas = document.createElement('canvas');
                    this.recordingCanvas.width = window.innerWidth;
                    this.recordingCanvas.height = window.innerHeight;
                    const ctx = this.recordingCanvas.getContext('2d');

                    // Get all visible canvases
                    const canvases = stageContainer.querySelectorAll('canvas');

                    // Start capturing frames
                    const stream = this.recordingCanvas.captureStream(30); // 30 FPS

                    // Add audio if available - use existing audio source to avoid "already connected" error
                    if (this.audioElement && this.audioSource) {
                        // Create destination for recording audio stream
                        this.recordingAudioDest = this.audioContext.createMediaStreamDestination();

                        // Connect existing audio source to recording destination
                        this.audioSource.connect(this.recordingAudioDest);

                        // Get audio track and add to recording stream
                        const audioTrack = this.recordingAudioDest.stream.getAudioTracks()[0];
                        if (audioTrack) {
                            stream.addTrack(audioTrack);
                        }
                    }

                    // Create MediaRecorder
                    const options = {
                        mimeType: 'video/webm;codecs=vp9',
                        videoBitsPerSecond: 8000000 // 8 Mbps for high quality
                    };

                    // Fallback if VP9 not supported
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options.mimeType = 'video/webm;codecs=vp8';
                    }

                    this.mediaRecorder = new MediaRecorder(stream, options);
                    this.recordedChunks = [];

                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.recordedChunks.push(event.data);
                        }
                    };

                    this.mediaRecorder.onstop = () => {
                        this.saveRecording();
                    };

                    // Start rendering loop for recording
                    const renderFrame = () => {
                        if (!this.isRecording) return;

                        // Clear composite canvas
                        ctx.clearRect(0, 0, this.recordingCanvas.width, this.recordingCanvas.height);

                        // Draw all canvases onto composite canvas
                        canvases.forEach(canvas => {
                            ctx.drawImage(canvas, 0, 0);
                        });

                        requestAnimationFrame(renderFrame);
                    };

                    // Start recording
                    this.mediaRecorder.start(100); // Collect data every 100ms
                    this.isRecording = true;
                    renderFrame();

                    // Update UI
                    document.getElementById('start-recording-btn').style.display = 'none';
                    document.getElementById('stop-recording-btn').style.display = 'block';
                    document.getElementById('recording-status').textContent = '‚è∫ RECORDING...';
                    document.getElementById('recording-timer').style.display = 'block';

                    // Start timer
                    this.recordingStartTime = Date.now();
                    this.recordingTimer = setInterval(() => {
                        const elapsed = Math.floor((Date.now() - this.recordingStartTime) / 1000);
                        const minutes = Math.floor(elapsed / 60);
                        const seconds = elapsed % 60;
                        document.getElementById('recording-timer').textContent =
                            `‚è± ${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }, 1000);

                    console.log('üé• Recording started');

                } catch (error) {
                    console.error('Recording error:', error);
                    alert(`Failed to start recording: ${error.message}`);
                }
            }

            stopRecording() {
                if (!this.mediaRecorder || !this.isRecording) return;

                this.isRecording = false;
                this.mediaRecorder.stop();

                // Disconnect recording audio destination if it exists
                if (this.recordingAudioDest) {
                    try {
                        this.recordingAudioDest.disconnect();
                        this.recordingAudioDest = null;
                    } catch (e) {
                        console.warn('Error disconnecting recording audio:', e);
                    }
                }

                // Stop timer
                if (this.recordingTimer) {
                    clearInterval(this.recordingTimer);
                    this.recordingTimer = null;
                }

                // Update UI
                document.getElementById('start-recording-btn').style.display = 'block';
                document.getElementById('stop-recording-btn').style.display = 'none';
                document.getElementById('recording-status').textContent = 'üíæ Saving video...';

                console.log('üé• Recording stopped');
            }

            saveRecording() {
                const blob = new Blob(this.recordedChunks, {
                    type: 'video/webm'
                });

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `vib34d-choreography-${Date.now()}.webm`;
                document.body.appendChild(a);
                a.click();

                // Cleanup
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);

                // Update UI
                document.getElementById('recording-status').textContent = '‚úÖ Video saved!';
                document.getElementById('recording-timer').style.display = 'none';

                setTimeout(() => {
                    document.getElementById('recording-status').textContent = '';
                }, 3000);

                console.log('‚úÖ Recording saved');
            }
        }

        // Initialize
        window.choreographer = new UltimateChoreographer();

        // Global LLM function
        window.generateFromAI = async function() {
            const input = document.getElementById('llm-input').value.trim();
            const apiKey = document.getElementById('llm-api-key-input').value.trim();
            const statusEl = document.getElementById('llm-status');

            if (!input) {
                statusEl.textContent = '‚ùå Please enter a description';
                statusEl.style.color = '#ff0080';
                return;
            }

            if (apiKey) {
                window.choreographer.llmInterface.setApiKey(apiKey);
            }

            statusEl.textContent = 'ü§ñ Generating parameters from AI...';
            statusEl.style.color = '#0ff';

            try {
                const parameters = await window.choreographer.llmInterface.generateParameters(input);
                console.log('ü§ñ AI Generated Parameters:', parameters);

                // Apply parameters to current engine
                const sys = window.choreographer.systems[window.choreographer.currentSystem];
                if (sys.engine && parameters) {
                    Object.entries(parameters).forEach(([param, value]) => {
                        window.choreographer.setParameter(param, value);
                    });
                    statusEl.textContent = '‚úÖ Parameters applied successfully!';
                    statusEl.style.color = '#00ff00';
                } else {
                    statusEl.textContent = '‚ö†Ô∏è Parameters generated but no active engine';
                    statusEl.style.color = '#ffaa00';
                }

            } catch (error) {
                console.error('ü§ñ AI Generation error:', error);
                statusEl.textContent = '‚ùå ' + error.message;
                statusEl.style.color = '#ff0000';
            }
        };
    </script>
</body>
</html>
